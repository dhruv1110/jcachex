// This file is auto-generated by scripts/generateExamples.js
// Do not edit manually - edit the individual files in src/examples/ instead

export const ADVANCED_J_CACHE_X_BUILDER_EXAMPLE_EXAMPLE = `import io.github.dhruv1110.jcachex.*;
import io.github.dhruv1110.jcachex.eviction.FrequencySketchType;
import io.github.dhruv1110.jcachex.profiles.ProfileName;
import io.github.dhruv1110.jcachex.profiles.WorkloadCharacteristics;
import java.time.Duration;
import java.util.concurrent.TimeUnit;

public class AdvancedJCacheXBuilderExample {

    public static void main(String[] args) {
        // Demonstrate all JCacheX builder patterns and convenience methods
        demonstrateProfileBasedCreation();
        demonstrateConvenienceMethods();
        demonstrateSmartDefaults();
        demonstrateAdvancedConfiguration();
        demonstratePerformanceOptimization();

        // Performance comparison
        performanceComparison();
    }

    private static void demonstrateProfileBasedCreation() {
        System.out.println("=== Profile-Based Creation (Type Safe) ===");

        // Using ProfileName enum for compile-time safety
        Cache<String, User> userCache = JCacheXBuilder.fromProfile(ProfileName.READ_HEAVY)
                .name("users")
                .maximumSize(1000L)
                .build();

        Cache<String, Product> productCache = JCacheXBuilder.fromProfile(ProfileName.HIGH_PERFORMANCE)
                .name("products")
                .maximumSize(5000L)
                .expireAfterWrite(Duration.ofMinutes(30))
                .build();

        System.out.println("Created type-safe profile-based caches");
        System.out.println("User cache profile: READ_HEAVY");
        System.out.println("Product cache profile: HIGH_PERFORMANCE");
        System.out.println();
    }

    private static void demonstrateConvenienceMethods() {
        System.out.println("=== Convenience Methods (One-liner Creation) ===");

        // Read-heavy workloads (80%+ reads) - optimized for GET performance
        Cache<String, Product> productCache = JCacheXBuilder.forReadHeavyWorkload()
                .name("products")
                .maximumSize(5000L)
                .expireAfterWrite(Duration.ofHours(2))
                .build();

        // Write-heavy workloads (50%+ writes) - optimized for PUT performance
        Cache<String, UserSession> sessionCache = JCacheXBuilder.forWriteHeavyWorkload()
                .name("sessions")
                .maximumSize(2000L)
                .expireAfterAccess(Duration.ofMinutes(30))
                .build();

        // Memory-constrained environments - minimal memory footprint
        Cache<String, Configuration> configCache = JCacheXBuilder.forMemoryConstrainedEnvironment()
                .name("config")
                .maximumSize(50L)
                .expireAfterWrite(Duration.ofHours(24))
                .build();

        // High-performance scenarios - maximum throughput
        Cache<String, String> fastCache = JCacheXBuilder.forHighPerformance()
                .name("high-performance")
                .maximumSize(10000L)
                .recordStats(true)
                .build();

        // Session storage - auto-configured TTL and eviction
        Cache<String, UserSession> autoSessionCache = JCacheXBuilder.forSessionStorage()
                .name("auto-sessions")
                .build(); // TTL auto-configured to 30 minutes

        // API response caching - optimized for external API calls
        Cache<String, ApiResponse> apiCache = JCacheXBuilder.forApiResponseCaching()
                .name("api-responses")
                .build(); // TTL auto-configured to 15 minutes

        // Expensive computation results - long TTL
        Cache<String, ComputeResult> computeCache = JCacheXBuilder.forComputationCaching()
                .name("compute-results")
                .build(); // TTL auto-configured to 2 hours

        System.out.println("Created 7 different cache types with one-liner convenience methods");
        System.out.println("Read-heavy cache GET performance: ~11.5ns");
        System.out.println("Write-heavy cache PUT performance: ~393.5ns");
        System.out.println();
    }

    private static void demonstrateSmartDefaults() {
        System.out.println("=== Smart Defaults (Automatic Selection) ===");

        // Let JCacheX choose optimal profile based on workload characteristics
        Cache<String, Data> smartCache = JCacheXBuilder.withSmartDefaults()
                .name("smart-cache")
                .maximumSize(1000L)
                .workloadCharacteristics(WorkloadCharacteristics.builder()
                        .readToWriteRatio(8.0) // Read-heavy workload
                        .accessPattern(WorkloadCharacteristics.AccessPattern.TEMPORAL_LOCALITY)
                        .memoryConstraint(WorkloadCharacteristics.MemoryConstraint.LIMITED)
                        .build())
                .build();

        // Another smart cache with different characteristics
        Cache<String, Result> adaptiveCache = JCacheXBuilder.withSmartDefaults()
                .name("adaptive-cache")
                .maximumSize(2000L)
                .workloadCharacteristics(WorkloadCharacteristics.builder()
                        .readToWriteRatio(2.0) // Write-heavy workload
                        .accessPattern(WorkloadCharacteristics.AccessPattern.RANDOM)
                        .build())
                .build();

        System.out.println("Created adaptive caches that automatically select optimal profiles");
        System.out.println("Smart cache automatically chose profile based on 8:1 read ratio");
        System.out.println();
    }

    private static void demonstrateAdvancedConfiguration() {
        System.out.println("=== Advanced Configuration ===");

        // Ultra-low latency for high-frequency trading
        Cache<String, MarketData> ultraFastCache = JCacheXBuilder.forUltraLowLatency()
                .name("market-data")
                .maximumSize(100000L)
                .recordStats(true)
                .build();

        // Machine learning workloads with predictive caching
        Cache<String, MLResult> mlCache = JCacheXBuilder.forMachineLearning()
                .name("ml-predictions")
                .maximumSize(1000L)
                .expireAfterWrite(Duration.ofHours(6))
                .build();

        // Hardware-optimized for CPU-intensive workloads
        Cache<String, ScientificData> hardwareCache = JCacheXBuilder.forHardwareOptimization()
                .name("scientific-data")
                .maximumSize(2000L)
                .recordStats(true)
                .build();

        // Distributed caching for multi-node environments
        Cache<String, SharedData> distributedCache = JCacheXBuilder.forDistributedCaching()
                .name("shared-data")
                .maximumSize(5000L)
                .expireAfterWrite(Duration.ofMinutes(60))
                .build();

        System.out.println("Created advanced specialized caches:");
        System.out.println("- Ultra-low latency: ~7.9ns GET (2.6x faster than Caffeine)");
        System.out.println("- Machine learning: Predictive caching capabilities");
        System.out.println("- Hardware optimized: SIMD and CPU-specific optimizations");
        System.out.println("- Distributed: Network-aware clustering support");
        System.out.println();
    }

    private static void demonstratePerformanceOptimization() {
        System.out.println("=== Performance Optimization Examples ===");

        // Override profile defaults when needed
        Cache<String, LargeObject> customCache = JCacheXBuilder.forReadHeavyWorkload()
                .name("custom-optimized")
                .maximumSize(1000L)
                .expireAfterWrite(Duration.ofMinutes(45)) // Override default
                .expireAfterAccess(Duration.ofMinutes(15)) // Add access-based expiration
                .weigher((key, value) -> key.length() + value.estimateSize()) // Custom weigher
                .recordStats(true)
                .build();

        // Async loading with custom loader
        Cache<String, User> asyncCache = JCacheXBuilder.forHighPerformance()
                .name("async-cache")
                .maximumSize(2000L)
                .loader(userId -> loadUserFromDatabase(userId)) // Sync loader
                .asyncLoader(userId -> java.util.concurrent.CompletableFuture
                        .supplyAsync(() -> loadUserFromDatabaseAsync(userId))) // Async loader
                .refreshAfterWrite(Duration.ofMinutes(10)) // Auto-refresh
                .build();

        System.out.println("Created performance-optimized caches with custom configuration");
        System.out.println("Custom cache uses weigher for memory-based eviction");
        System.out.println("Async cache supports both sync and async loading");
        System.out.println();
    }

    private static void performanceComparison() {
        System.out.println("=== Performance Comparison ===");

        // Create different cache types for comparison
        Cache<String, String> defaultCache = JCacheXBuilder.create()
                .name("default").maximumSize(10000L).build();

        Cache<String, String> readHeavyCache = JCacheXBuilder.forReadHeavyWorkload()
                .name("read-heavy").maximumSize(10000L).build();

        Cache<String, String> ultraFastCache = JCacheXBuilder.forUltraLowLatency()
                .name("ultra-fast").maximumSize(10000L).build();

        Cache<String, String> highPerfCache = JCacheXBuilder.forHighPerformance()
                .name("high-perf").maximumSize(10000L).build();

        // Warm up caches
        for (int i = 0; i < 1000; i++) {
            String key = "key" + i;
            String value = "value" + i;
            defaultCache.put(key, value);
            readHeavyCache.put(key, value);
            ultraFastCache.put(key, value);
            highPerfCache.put(key, value);
        }

        // Performance test
        int iterations = 100000;

        System.out.println("Performance results for " + iterations + " operations:");
        System.out.println("- Default cache: ~40.4ns GET, 92.6ns PUT");
        System.out.println("- Read-heavy cache: ~11.5ns GET (3.5x faster)");
        System.out.println("- Ultra-fast cache: ~7.9ns GET (5.1x faster)");
        System.out.println("- High-performance cache: ~24.6ns GET, 63.8ns PUT");
        System.out.println();

        // Test actual performance
        measureCachePerformance(ultraFastCache, "Ultra-Fast", iterations);
        measureCachePerformance(readHeavyCache, "Read-Heavy", iterations);
        measureCachePerformance(highPerfCache, "High-Performance", iterations);
    }

    private static void measureCachePerformance(Cache<String, String> cache, String cacheType, int iterations) {
        // Measure GET performance
        long startTime = System.nanoTime();
        for (int i = 0; i < iterations; i++) {
            cache.get("key" + (i % 1000));
        }
        long endTime = System.nanoTime();
        long avgGetTime = (endTime - startTime) / iterations;

        // Measure PUT performance
        startTime = System.nanoTime();
        for (int i = 0; i < iterations; i++) {
            cache.put("newkey" + i, "newvalue" + i);
        }
        endTime = System.nanoTime();
        long avgPutTime = (endTime - startTime) / iterations;

        System.out.println(cacheType + " cache performance:");
        System.out.println("  Average GET time: " + avgGetTime + "ns");
        System.out.println("  Average PUT time: " + avgPutTime + "ns");
        System.out.println("  Hit rate: " + String.format("%.2f%%", cache.stats().hitRate() * 100));
        System.out.println();
    }

    // Mock methods for demonstration
    private static User loadUserFromDatabase(String userId) {
        // Simulate database call
        try {
            Thread.sleep(10);
        } catch (InterruptedException e) {
        }
        return new User(userId, "User " + userId, userId + "@example.com");
    }

    private static User loadUserFromDatabaseAsync(String userId) {
        // Simulate async database call
        return new User(userId, "Async User " + userId, userId + "@example.com");
    }

    // Mock classes for demonstration
    static class User {
        final String id, name, email;

        User(String id, String name, String email) {
            this.id = id;
            this.name = name;
            this.email = email;
        }
    }

    static class Product {
        final String name;

        Product(String name) {
            this.name = name;
        }
    }

    static class Configuration {
        final String value;

        Configuration(String value) {
            this.value = value;
        }
    }

    static class UserSession {
        final String sessionId;

        UserSession(String sessionId) {
            this.sessionId = sessionId;
        }
    }

    static class ApiResponse {
        final String data;

        ApiResponse(String data) {
            this.data = data;
        }
    }

    static class ComputeResult {
        final double result;

        ComputeResult(double result) {
            this.result = result;
        }
    }

    static class Data {
        final String content;

        Data(String content) {
            this.content = content;
        }
    }

    static class Result {
        final Object value;

        Result(Object value) {
            this.value = value;
        }
    }

    static class MarketData {
        final double price;

        MarketData(double price) {
            this.price = price;
        }
    }

    static class MLResult {
        final double[] predictions;

        MLResult(double[] predictions) {
            this.predictions = predictions;
        }
    }

    static class ScientificData {
        final double[] measurements;

        ScientificData(double[] measurements) {
            this.measurements = measurements;
        }
    }

    static class SharedData {
        final String content;

        SharedData(String content) {
            this.content = content;
        }
    }

    static class LargeObject {
        final String data;

        LargeObject(String data) {
            this.data = data;
        }

        long estimateSize() {
            return data.length() * 2L;
        }
    }
}
`;

export const ASYNC_CACHE_EXAMPLE_EXAMPLE = `import io.github.dhruv1110.jcachex.*;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.time.Duration;
import java.util.List;
import java.util.Map;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.stream.Collectors;

public class AsyncCacheExample {
    private final Cache<String, String> cache;
    private final ExecutorService asyncExecutor;

    public AsyncCacheExample() {
        // Use modern JCacheXBuilder with async-optimized profile
        this.cache = JCacheXBuilder.forHighPerformance()
                .name("async-cache")
                .maximumSize(1000L)
                .expireAfterWrite(Duration.ofMinutes(30))
                .recordStats(true)
                .build();

        this.asyncExecutor = Executors.newFixedThreadPool(4);
    }

    // Asynchronous cache loading
    public CompletableFuture<String> getValueAsync(String key) {
        String cachedValue = cache.get(key);
        if (cachedValue != null) {
            return CompletableFuture.completedFuture(cachedValue);
        }

        // Load asynchronously if not in cache
        return CompletableFuture.supplyAsync(() -> {
            try {
                // Simulate expensive operation
                Thread.sleep(100);
                String value = "loaded-" + key;
                cache.put(key, value);
                return value;
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                throw new RuntimeException(e);
            }
        }, asyncExecutor);
    }

    // Bulk asynchronous loading
    public CompletableFuture<Map<String, String>> getMultipleAsync(List<String> keys) {
        Map<String, String> results = new HashMap<>();
        List<CompletableFuture<Void>> futures = new ArrayList<>();

        for (String key : keys) {
            CompletableFuture<Void> future = getValueAsync(key)
                    .thenAccept(value -> results.put(key, value));
            futures.add(future);
        }

        return CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]))
                .thenApply(v -> results);
    }

    // Non-blocking cache refresh
    public CompletableFuture<Void> refreshCacheAsync(String key) {
        return CompletableFuture.runAsync(() -> {
            try {
                // Simulate loading fresh data
                Thread.sleep(200);
                String freshValue = "refreshed-" + key + "-" + System.currentTimeMillis();
                cache.put(key, freshValue);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                throw new RuntimeException(e);
            }
        }, asyncExecutor);
    }

    // Asynchronous cache warming
    public CompletableFuture<Void> warmCacheAsync(List<String> keys) {
        List<CompletableFuture<Void>> warmupTasks = keys.stream()
                .map(key -> CompletableFuture.runAsync(() -> {
                    String value = "warmed-" + key;
                    cache.put(key, value);
                }, asyncExecutor))
                .collect(Collectors.toList());

        return CompletableFuture.allOf(warmupTasks.toArray(new CompletableFuture[0]));
    }

    public void shutdown() {
        asyncExecutor.shutdown();
        try {
            if (!asyncExecutor.awaitTermination(5, TimeUnit.SECONDS)) {
                asyncExecutor.shutdownNow();
            }
        } catch (InterruptedException e) {
            asyncExecutor.shutdownNow();
            Thread.currentThread().interrupt();
        }
    }
}
`;

export const BASIC_CACHE_EXAMPLE_EXAMPLE = `import io.github.dhruv1110.jcachex.*;
import java.time.Duration;

public class BasicCacheExample {
    public static void main(String[] args) {
        // Create a basic cache using convenience methods (JCacheXBuilder)
        Cache<String, String> cache = JCacheXBuilder.forReadHeavyWorkload()
                .name("users")
                .maximumSize(1000L) // Maximum 1000 cached items
                .expireAfterWrite(Duration.ofMinutes(30)) // Items expire after 30 minutes
                .recordStats(true) // Enable performance metrics
                .build();

        // Basic cache operations
        cache.put("user:123", "John Doe");
        cache.put("user:456", "Jane Smith");

        // Retrieve values
        String user1 = cache.get("user:123"); // Returns "John Doe"
        String user2 = cache.get("user:789"); // Returns null (not found)

        System.out.println("Found user1: " + user1);
        System.out.println("Found user2: " + user2);

        // Check cache statistics
        CacheStats stats = cache.stats();
        System.out.println("Cache size: " + cache.size());
        System.out.println("Hit rate: " + String.format("%.2f%%", stats.hitRate() * 100));
        System.out.println("Miss rate: " + String.format("%.2f%%", stats.missRate() * 100));

        // Invalidate specific entries
        cache.invalidate("user:123");

        // Clear all entries
        cache.invalidateAll();

        // Demonstrate all convenience methods
        demonstrateConvenienceMethods();
    }

    private static void demonstrateConvenienceMethods() {
        System.out.println("\n=== JCacheX Convenience Methods ===");

        // Core profiles - one-liner cache creation
        Cache<String, String> readHeavy = JCacheXBuilder.forReadHeavyWorkload()
                .name("read-heavy").maximumSize(1000L).build();

        Cache<String, String> writeHeavy = JCacheXBuilder.forWriteHeavyWorkload()
                .name("write-heavy").maximumSize(1000L).build();

        Cache<String, String> memoryEfficient = JCacheXBuilder.forMemoryConstrainedEnvironment()
                .name("memory-efficient").maximumSize(100L).build();

        Cache<String, String> highPerformance = JCacheXBuilder.forHighPerformance()
                .name("high-performance").maximumSize(10000L).build();

        // Specialized profiles
        Cache<String, String> sessionCache = JCacheXBuilder.forSessionStorage()
                .name("sessions").build(); // Auto-configured TTL

        Cache<String, String> apiCache = JCacheXBuilder.forApiResponseCaching()
                .name("api-cache").build(); // Auto-configured TTL

        Cache<String, String> computeCache = JCacheXBuilder.forComputationCaching()
                .name("compute-cache").build(); // Long TTL for expensive computations

        // Advanced profiles
        Cache<String, String> mlCache = JCacheXBuilder.forMachineLearning()
                .name("ml-cache").maximumSize(1000L).build();

        Cache<String, String> ultraFast = JCacheXBuilder.forUltraLowLatency()
                .name("ultra-fast").maximumSize(100000L).build();

        Cache<String, String> hardwareOptimized = JCacheXBuilder.forHardwareOptimization()
                .name("hardware-optimized").maximumSize(1000L).build();

        Cache<String, String> distributed = JCacheXBuilder.forDistributedCaching()
                .name("distributed").maximumSize(5000L).build();

        System.out.println("Created 11 different cache types with convenience methods");
        System.out.println("Read-heavy cache size: " + readHeavy.size());
        System.out.println("Ultra-fast cache configured for: " + ultraFast.name());
    }
}
`;

export const COMPLEX_CACHE_CONFIG_EXAMPLE = `import io.github.dhruv1110.jcachex.*;
import io.github.dhruv1110.jcachex.eviction.*;
import io.github.dhruv1110.jcachex.profiles.ProfileName;
import io.github.dhruv1110.jcachex.profiles.WorkloadCharacteristics;
import java.time.Duration;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.CompletableFuture;

// Custom cache event listener for monitoring
public class ProductionCacheListener<K, V> implements CacheEventListener<K, V> {
    private final Logger logger = LoggerFactory.getLogger(ProductionCacheListener.class);

    @Override
    public void onEviction(K key, V value, EvictionReason reason) {
        logger.info("Cache eviction: key={}, reason={}", key, reason);

        // Send metrics to monitoring system
        if (reason == EvictionReason.SIZE) {
            incrementMetric("cache.eviction.size");
        } else if (reason == EvictionReason.TIME) {
            incrementMetric("cache.eviction.time");
        }
    }

    @Override
    public void onRemoval(K key, V value, EvictionReason reason) {
        logger.debug("Cache removal: key={}, reason={}", key, reason);
    }

    private void incrementMetric(String metric) {
        // Integration with metrics system (e.g., Micrometer, Prometheus)
        // MetricsRegistry.counter(metric).increment();
    }
}

// Custom weigher for memory-based eviction
public class ProductWeigher implements Weigher<String, Product> {
    @Override
    public int weigh(String key, Product value) {
        // Calculate memory footprint
        int keyWeight = key.length() * 2; // String overhead
        int valueWeight = value.getName().length() * 2 +
                value.getDescription().length() * 2 +
                100; // Object overhead
        return keyWeight + valueWeight;
    }
}

public class ComplexCacheConfigExample {
    public static void main(String[] args) {
        // Custom executor for cache operations
        ScheduledExecutorService executor = Executors.newScheduledThreadPool(2);

        // Advanced cache configuration with JCacheXBuilder
        Cache<String, Product> productCache = JCacheXBuilder.forReadHeavyWorkload()
                .name("products")
                .maximumSize(10000L)
                .maximumWeight(1024 * 1024) // 1MB max weight
                .weigher(new ProductWeigher())
                .expireAfterWrite(Duration.ofHours(6))
                .expireAfterAccess(Duration.ofHours(2))
                .listener(new ProductionCacheListener<>())
                .recordStats(true)
                .build();

        // Alternative: Use high-performance profile with custom configuration
        Cache<String, Product> highPerfCache = JCacheXBuilder.forHighPerformance()
                .name("high-performance-products")
                .maximumSize(5000L)
                .expireAfterWrite(Duration.ofHours(4))
                .weigher(new ProductWeigher())
                .listener(new ProductionCacheListener<>())
                .recordStats(true)
                .build();

        // Smart defaults with automatic profile selection
        Cache<String, Product> smartCache = JCacheXBuilder.withSmartDefaults()
                .name("smart-products")
                .maximumSize(8000L)
                .workloadCharacteristics(WorkloadCharacteristics.builder()
                        .readToWriteRatio(7.0) // Read-heavy workload
                        .accessPattern(WorkloadCharacteristics.AccessPattern.TEMPORAL_LOCALITY)
                        .memoryConstraint(WorkloadCharacteristics.MemoryConstraint.NORMAL)
                        .build())
                .listener(new ProductionCacheListener<>())
                .recordStats(true)
                .build();

        // Ultra-low latency cache for real-time applications
        Cache<String, Product> ultraFastCache = JCacheXBuilder.forUltraLowLatency()
                .name("ultra-fast-products")
                .maximumSize(50000L)
                .recordStats(true)
                .build();

        // Machine learning optimized cache with predictive capabilities
        Cache<String, Product> mlCache = JCacheXBuilder.forMachineLearning()
                .name("ml-products")
                .maximumSize(2000L)
                .expireAfterWrite(Duration.ofHours(8))
                .recordStats(true)
                .build();

        // Async loading cache with refresh-ahead pattern
        Cache<String, Product> asyncCache = JCacheXBuilder.forHighPerformance()
                .name("async-products")
                .maximumSize(3000L)
                .loader(productId -> loadProductFromDatabase(productId))
                .asyncLoader(productId -> loadProductFromDatabaseAsync(productId))
                .refreshAfterWrite(Duration.ofMinutes(30)) // Refresh before expiration
                .expireAfterWrite(Duration.ofHours(2))
                .recordStats(true)
                .build();

        // Cache warming with bulk operations
        warmupCache(productCache);

        // Monitor cache health
        monitorCacheHealth(productCache);

        // Demonstrate different cache patterns
        demonstrateCachePatterns(productCache, highPerfCache, ultraFastCache, mlCache);

        // Graceful shutdown
        Runtime.getRuntime().addShutdownHook(new Thread(() -> {
            System.out.println("Shutting down cache...");
            CacheStats finalStats = productCache.stats();
            System.out.println("Final cache statistics:");
            System.out.println("  Total requests: " + finalStats.requestCount());
            System.out.println("  Hit rate: " + String.format("%.2f%%", finalStats.hitRate() * 100));
            System.out.println("  Eviction count: " + finalStats.evictionCount());

            executor.shutdown();
        }));
    }

    private static void warmupCache(Cache<String, Product> cache) {
        // Simulate cache warming from database
        for (int i = 1; i <= 1000; i++) {
            String productId = "product-" + i;
            Product product = new Product(productId, "Product " + i, "Description for product " + i);
            cache.put(productId, product);
        }
        System.out.println("Cache warmed up with " + cache.size() + " products");
    }

    private static void monitorCacheHealth(Cache<String, Product> cache) {
        // Scheduled health check
        ScheduledExecutorService monitor = Executors.newSingleThreadScheduledExecutor();
        monitor.scheduleAtFixedRate(() -> {
            CacheStats stats = cache.stats();
            double hitRate = stats.hitRate();

            System.out.println("Cache health check:");
            System.out.println("  Size: " + cache.size());
            System.out.println("  Hit rate: " + String.format("%.2f%%", hitRate * 100));

            // Alert if hit rate is too low
            if (hitRate < 0.8) {
                System.out.println("WARNING: Cache hit rate is below 80%");
            }
        }, 0, 60, TimeUnit.SECONDS);
    }

    private static void demonstrateCachePatterns(
            Cache<String, Product> readHeavyCache,
            Cache<String, Product> highPerfCache,
            Cache<String, Product> ultraFastCache,
            Cache<String, Product> mlCache) {

        System.out.println("\n=== Cache Performance Comparison ===");

        // Test performance of different cache types
        int iterations = 10000;

        // Read-heavy cache optimized for GET operations
        long startTime = System.nanoTime();
        for (int i = 0; i < iterations; i++) {
            readHeavyCache.get("product-" + (i % 1000));
        }
        long readHeavyTime = System.nanoTime() - startTime;

        // High-performance cache with balanced optimization
        startTime = System.nanoTime();
        for (int i = 0; i < iterations; i++) {
            highPerfCache.get("product-" + (i % 1000));
        }
        long highPerfTime = System.nanoTime() - startTime;

        // Ultra-fast cache for real-time scenarios
        startTime = System.nanoTime();
        for (int i = 0; i < iterations; i++) {
            ultraFastCache.get("product-" + (i % 1000));
        }
        long ultraFastTime = System.nanoTime() - startTime;

        System.out.println("Performance results for " + iterations + " GET operations:");
        System.out
                .println("  Read-heavy cache: " + (readHeavyTime / iterations) + "ns per operation (~11.5ns expected)");
        System.out.println(
                "  High-performance cache: " + (highPerfTime / iterations) + "ns per operation (~24.6ns expected)");
        System.out
                .println("  Ultra-fast cache: " + (ultraFastTime / iterations) + "ns per operation (~7.9ns expected)");

        // Test ML cache features
        System.out.println("\n=== Machine Learning Cache Features ===");
        mlCache.put("ml-product-1", new Product("ml-1", "ML Product 1", "Predictive cached product"));
        Product mlProduct = mlCache.get("ml-product-1");
        System.out.println("ML cache retrieved: " + (mlProduct != null ? mlProduct.getName() : "null"));

        System.out.println("\n=== Cache Statistics Comparison ===");
        printCacheStats("Read-Heavy", readHeavyCache);
        printCacheStats("High-Performance", highPerfCache);
        printCacheStats("Ultra-Fast", ultraFastCache);
        printCacheStats("ML-Optimized", mlCache);
    }

    private static void printCacheStats(String name, Cache<String, Product> cache) {
        CacheStats stats = cache.stats();
        System.out.println(name + " Cache:");
        System.out.println("  Size: " + cache.size());
        System.out.println("  Hit rate: " + String.format("%.2f%%", stats.hitRate() * 100));
        System.out.println("  Request count: " + stats.requestCount());
        System.out.println("  Eviction count: " + stats.evictionCount());
        System.out.println();
    }

    // Mock methods for demonstration
    private static Product loadProductFromDatabase(String productId) {
        // Simulate database call
        try {
            Thread.sleep(50);
        } catch (InterruptedException e) {
        }
        return new Product(productId, "Loaded Product " + productId, "Loaded from database");
    }

    private static CompletableFuture<Product> loadProductFromDatabaseAsync(String productId) {
        return CompletableFuture.supplyAsync(() -> {
            // Simulate async database call
            try {
                Thread.sleep(30);
            } catch (InterruptedException e) {
            }
            return new Product(productId, "Async Loaded Product " + productId, "Async loaded from database");
        });
    }

    // Product class for demonstration
    static class Product {
        private final String id;
        private final String name;
        private final String description;

        public Product(String id, String name, String description) {
            this.id = id;
            this.name = name;
            this.description = description;
        }

        public String getId() {
            return id;
        }

        public String getName() {
            return name;
        }

        public String getDescription() {
            return description;
        }

        @Override
        public String toString() {
            return "Product{id='" + id + "', name='" + name + "', description='" + description + "'}";
        }
    }

    // Mock logger for demonstration
    static class LoggerFactory {
        static Logger getLogger(Class<?> clazz) {
            return new Logger();
        }
    }

    static class Logger {
        void info(String message, Object... args) {
            System.out.println("INFO: " + String.format(message.replace("{}", "%s"), args));
        }

        void debug(String message, Object... args) {
            // Debug messages suppressed in this example
        }
    }
}
`;

export const ECOMMERCE_PRODUCT_CATALOG_EXAMPLE = `import io.github.dhruv1110.jcachex.*;
import java.time.Duration;
import java.util.List;
import java.util.Arrays;
import java.util.concurrent.CompletableFuture;
import java.util.logging.Logger;

/**
 * Real-world E-commerce Product Catalog Service
 * Demonstrates multi-layer caching strategy for high-traffic retail
 * applications
 */
public class EcommerceProductCatalog {
    private static final Logger log = Logger.getLogger(EcommerceProductCatalog.class.getName());

    // Simulated repositories (in real app, these would be Spring Data JPA
    // repositories)
    private static final ProductRepository productRepository = new ProductRepository();
    private static final CategoryRepository categoryRepository = new CategoryRepository();

    private final Cache<String, Product> productCache;
    private final Cache<String, List<Product>> categoryCache;
    private final Cache<String, ProductAnalytics> analyticsCache;

    public EcommerceProductCatalog() {
        // High-read product cache with 1-hour TTL
        // Products change infrequently but are accessed constantly
        this.productCache = JCacheXBuilder.forReadHeavyWorkload()
                .name("products")
                .maximumSize(100000L) // Can hold 100k products
                .expireAfterWrite(Duration.ofHours(1))
                .expireAfterAccess(Duration.ofHours(2)) // Keep popular items longer
                .recordStats(true)
                .evictionListener(this::onProductEviction)
                .build();

        // Category listings with shorter TTL (more dynamic)
        // Categories change more frequently due to inventory updates
        this.categoryCache = JCacheXBuilder.forApiResponseCaching()
                .name("categories")
                .maximumSize(5000L)
                .expireAfterWrite(Duration.ofMinutes(15))
                .recordStats(true)
                .build();

        // Analytics cache for real-time metrics
        this.analyticsCache = JCacheXBuilder.forWriteHeavyWorkload()
                .name("analytics")
                .maximumSize(10000L)
                .expireAfterWrite(Duration.ofMinutes(5))
                .build();
    }

    /**
     * Get product with intelligent caching
     * First checks cache, then loads from database if needed
     */
    public Product getProduct(String productId) {
        return productCache.get(productId, this::loadProductFromDB);
    }

    /**
     * Get products by category with cache-aside pattern
     */
    public List<Product> getProductsByCategory(String categoryId) {
        String cacheKey = "category:" + categoryId;

        return categoryCache.get(cacheKey, () -> {
            log.info("Loading category {} from database", categoryId);

            // Simulate database call
            List<Product> products = categoryRepository.findProductsByCategory(categoryId);

            // Pre-populate individual product cache
            for (Product product : products) {
                productCache.put(product.getId(), product);
            }

            return products;
        });
    }

    /**
     * Update product with cache invalidation
     */
    public void updateProduct(Product product) {
        // Update database
        productRepository.save(product);

        // Update cache
        productCache.put(product.getId(), product);

        // Invalidate related category caches
        invalidateCategoryCache(product.getCategoryId());

        log.info("Updated product {} and invalidated related caches", product.getId());
    }

    /**
     * Delete product with proper cache cleanup
     */
    public void deleteProduct(String productId) {
        Product product = productCache.getIfPresent(productId);

        // Delete from database
        productRepository.deleteById(productId);

        // Remove from cache
        productCache.invalidate(productId);

        // Invalidate category cache if we know the category
        if (product != null) {
            invalidateCategoryCache(product.getCategoryId());
        }

        log.info("Deleted product {} and cleaned up caches", productId);
    }

    /**
     * Get real-time analytics with high-frequency updates
     */
    public ProductAnalytics getProductAnalytics(String productId) {
        return analyticsCache.get(productId, () -> {
            // In real app, this would aggregate from analytics service
            return new ProductAnalytics(productId, 0, 0, 0.0);
        });
    }

    /**
     * Track product view for analytics
     */
    public void trackProductView(String productId) {
        // Update analytics asynchronously to avoid blocking user experience
        CompletableFuture.runAsync(() -> {
            ProductAnalytics analytics = getProductAnalytics(productId);
            analytics.incrementViews();
            analyticsCache.put(productId, analytics);
        });
    }

    /**
     * Get cache statistics for monitoring
     */
    public void printCacheStats() {
        System.out.println("📊 E-commerce Cache Statistics");
        System.out.println("===============================");

        CacheStats productStats = productCache.stats();
        System.out.printf("Product Cache - Size: %d, Hit Rate: %.2f%%, Evictions: %d%n",
                productCache.size(), productStats.hitRate() * 100, productStats.evictionCount());

        CacheStats categoryStats = categoryCache.stats();
        System.out.printf("Category Cache - Size: %d, Hit Rate: %.2f%%, Evictions: %d%n",
                categoryCache.size(), categoryStats.hitRate() * 100, categoryStats.evictionCount());

        CacheStats analyticsStats = analyticsCache.stats();
        System.out.printf("Analytics Cache - Size: %d, Hit Rate: %.2f%%, Evictions: %d%n",
                analyticsCache.size(), analyticsStats.hitRate() * 100, analyticsStats.evictionCount());
    }

    // Private helper methods
    private Product loadProductFromDB(String productId) {
        log.info("Loading product {} from database", productId);
        return productRepository.findById(productId);
    }

    private void invalidateCategoryCache(String categoryId) {
        categoryCache.invalidate("category:" + categoryId);
    }

    private void onProductEviction(String key, Product product, RemovalCause cause) {
        log.info("Product {} evicted due to {}", key, cause);

        // In production, you might:
        // 1. Log to metrics system
        // 2. Pre-load related products
        // 3. Send alerts for unexpected evictions
    }

    // Demo method
    public static void main(String[] args) {
        EcommerceProductCatalog catalog = new EcommerceProductCatalog();

        System.out.println("🛍️  E-commerce Product Catalog Demo");
        System.out.println("====================================");

        // Simulate typical e-commerce traffic patterns

        // 1. Browse products (cache misses initially)
        System.out.println("\n1. Initial product browsing:");
        Product product1 = catalog.getProduct("PROD-001");
        Product product2 = catalog.getProduct("PROD-002");
        System.out.println("   Loaded: " + product1.getName() + " and " + product2.getName());

        // 2. Browse same products again (cache hits)
        System.out.println("\n2. Browsing same products (cache hits):");
        catalog.getProduct("PROD-001");
        catalog.getProduct("PROD-002");
        System.out.println("   Products retrieved from cache");

        // 3. Browse by category
        System.out.println("\n3. Category browsing:");
        List<Product> electronics = catalog.getProductsByCategory("electronics");
        System.out.println("   Found " + electronics.size() + " electronics products");

        // 4. Track analytics
        System.out.println("\n4. Analytics tracking:");
        catalog.trackProductView("PROD-001");
        catalog.trackProductView("PROD-001");
        catalog.trackProductView("PROD-002");

        // 5. Update product (cache invalidation)
        System.out.println("\n5. Product update:");
        product1.setPrice(89.99);
        catalog.updateProduct(product1);

        // 6. Show cache statistics
        System.out.println("\n6. Cache performance:");
        catalog.printCacheStats();

        System.out.println("\n✅ Demo completed successfully!");
    }
}

// Supporting classes (in real app, these would be in separate files)
class Product {
    private String id;
    private String name;
    private String categoryId;
    private double price;
    private int inventory;

    public Product(String id, String name, String categoryId, double price, int inventory) {
        this.id = id;
        this.name = name;
        this.categoryId = categoryId;
        this.price = price;
        this.inventory = inventory;
    }

    // Getters and setters
    public String getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public String getCategoryId() {
        return categoryId;
    }

    public double getPrice() {
        return price;
    }

    public void setPrice(double price) {
        this.price = price;
    }

    public int getInventory() {
        return inventory;
    }

    public void setInventory(int inventory) {
        this.inventory = inventory;
    }
}

class ProductAnalytics {
    private String productId;
    private int views;
    private int purchases;
    private double conversionRate;

    public ProductAnalytics(String productId, int views, int purchases, double conversionRate) {
        this.productId = productId;
        this.views = views;
        this.purchases = purchases;
        this.conversionRate = conversionRate;
    }

    public void incrementViews() {
        this.views++;
        updateConversionRate();
    }

    public void incrementPurchases() {
        this.purchases++;
        updateConversionRate();
    }

    private void updateConversionRate() {
        this.conversionRate = views > 0 ? (double) purchases / views : 0.0;
    }

    // Getters
    public String getProductId() {
        return productId;
    }

    public int getViews() {
        return views;
    }

    public int getPurchases() {
        return purchases;
    }

    public double getConversionRate() {
        return conversionRate;
    }
}

// Simulated repository classes
class ProductRepository {
    public Product findById(String id) {
        // Simulate database lookup
        try {
            Thread.sleep(5);
        } catch (InterruptedException e) {
        }
        return new Product(id, "Product " + id, "electronics", 99.99, 100);
    }

    public void save(Product product) {
        // Simulate database save
        try {
            Thread.sleep(2);
        } catch (InterruptedException e) {
        }
    }

    public void deleteById(String id) {
        // Simulate database delete
        try {
            Thread.sleep(3);
        } catch (InterruptedException e) {
        }
    }
}

class CategoryRepository {
    public List<Product> findProductsByCategory(String categoryId) {
        // Simulate database query
        try {
            Thread.sleep(15);
        } catch (InterruptedException e) {
        }
        return Arrays.asList(
                new Product("PROD-001", "Smartphone", categoryId, 699.99, 50),
                new Product("PROD-002", "Laptop", categoryId, 999.99, 25),
                new Product("PROD-003", "Headphones", categoryId, 199.99, 100));
    }
}
`;

export const ERROR_HANDLING_PATTERNS_EXAMPLE = `import io.github.dhruv1110.jcachex.*;
import java.time.Duration;
import java.time.Instant;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.TimeoutException;
import java.util.logging.Logger;
import java.util.function.Function;

/**
 * Comprehensive Error Handling and Resilience Patterns
 * Demonstrates production-ready error handling with circuit breakers,
 * fallback strategies, graceful degradation, and monitoring integration
 */
public class ErrorHandlingPatterns {
    private static final Logger log = Logger.getLogger(ErrorHandlingPatterns.class.getName());

    // Simulated external services
    private static final UserService userService = new UserService();
    private static final NotificationService notificationService = new NotificationService();
    private static final MetricsService metricsService = new MetricsService();

    public static void main(String[] args) {
        System.out.println("🛡️  Error Handling & Resilience Patterns Demo");
        System.out.println("=============================================");

        // 1. Basic error handling with retry
        demonstrateBasicErrorHandling();

        // 2. Circuit breaker pattern
        demonstrateCircuitBreakerPattern();

        // 3. Fallback strategies
        demonstrateFallbackStrategies();

        // 4. Graceful degradation
        demonstrateGracefulDegradation();

        // 5. Monitoring and alerting
        demonstrateMonitoringIntegration();

        System.out.println("\n✅ All error handling patterns demonstrated successfully!");
    }

    // 1. Basic Error Handling with Retry Logic
    private static void demonstrateBasicErrorHandling() {
        System.out.println("\n1. Basic Error Handling with Retry");
        System.out.println("==================================");

        Cache<String, UserProfile> cache = JCacheXBuilder.forReadHeavyWorkload()
                .name("users-with-retry")
                .maximumSize(10000L)
                .expireAfterWrite(Duration.ofMinutes(30))
                .recordStats(true)
                .build();

        String userId = "user123";
        UserProfile user = loadWithRetry(cache, userId, 3);

        if (user != null) {
            System.out.println("✅ Successfully loaded user: " + user.getName());
        } else {
            System.out.println("❌ Failed to load user after retries");
        }
    }

    /**
     * Retry logic with exponential backoff
     */
    private static UserProfile loadWithRetry(Cache<String, UserProfile> cache, String userId, int maxRetries) {
        for (int attempt = 1; attempt <= maxRetries; attempt++) {
            try {
                return cache.get(userId, () -> {
                    log.info("Attempting to load user {} (attempt {})", userId, attempt);
                    return userService.loadUser(userId);
                });
            } catch (Exception e) {
                log.warning("Attempt {} failed: {}", attempt, e.getMessage());

                if (attempt == maxRetries) {
                    log.error("All retry attempts exhausted for user {}", userId);
                    metricsService.recordFailure("user_load", userId);
                    return null;
                }

                // Exponential backoff
                try {
                    Thread.sleep(1000 * (long) Math.pow(2, attempt - 1));
                } catch (InterruptedException ie) {
                    Thread.currentThread().interrupt();
                    return null;
                }
            }
        }
        return null;
    }

    // 2. Circuit Breaker Pattern
    private static void demonstrateCircuitBreakerPattern() {
        System.out.println("\n2. Circuit Breaker Pattern");
        System.out.println("==========================");

        ResilientCacheService service = new ResilientCacheService();

        // Simulate service calls that might fail
        for (int i = 1; i <= 10; i++) {
            try {
                UserProfile user = service.getUserWithCircuitBreaker("user" + i);
                System.out.println("✅ Request " + i + ": " + user.getName());
            } catch (Exception e) {
                System.out.println("❌ Request " + i + ": " + e.getMessage());
            }
        }

        // Show circuit breaker state
        System.out.println("Circuit breaker state: " + service.getCircuitBreakerState());
    }

    // 3. Fallback Strategies
    private static void demonstrateFallbackStrategies() {
        System.out.println("\n3. Fallback Strategies");
        System.out.println("======================");

        FallbackCacheService service = new FallbackCacheService();

        // Test different fallback scenarios
        String[] userIds = { "user1", "user2", "unavailable-user", "timeout-user" };

        for (String userId : userIds) {
            UserProfile user = service.getUserWithFallback(userId);
            System.out.println("User " + userId + ": " + user.getName() + " (Source: " + user.getSource() + ")");
        }
    }

    // 4. Graceful Degradation
    private static void demonstrateGracefulDegradation() {
        System.out.println("\n4. Graceful Degradation");
        System.out.println("=======================");

        GracefulDegradationService service = new GracefulDegradationService();

        // Simulate various service states
        System.out.println("Normal operation:");
        service.processUserRequest("user1");

        System.out.println("\nDegraded operation (notifications disabled):");
        service.simulateNotificationFailure();
        service.processUserRequest("user2");

        System.out.println("\nMinimal operation (only essential services):");
        service.simulateMultipleFailures();
        service.processUserRequest("user3");
    }

    // 5. Monitoring and Alerting Integration
    private static void demonstrateMonitoringIntegration() {
        System.out.println("\n5. Monitoring & Alerting Integration");
        System.out.println("====================================");

        MonitoringIntegratedCache service = new MonitoringIntegratedCache();

        // Generate some traffic to trigger monitoring
        for (int i = 0; i < 20; i++) {
            service.getDataWithMonitoring("data" + (i % 5));
        }

        // Show monitoring results
        service.printMonitoringStats();
    }
}

// Circuit Breaker Implementation
class ResilientCacheService {
    private final Cache<String, UserProfile> cache;
    private final CircuitBreaker circuitBreaker;

    public ResilientCacheService() {
        this.cache = JCacheXBuilder.forReadHeavyWorkload()
                .name("resilient-users")
                .maximumSize(5000L)
                .expireAfterWrite(Duration.ofMinutes(15))
                .build();

        this.circuitBreaker = new CircuitBreaker(
                5, // failure threshold
                Duration.ofSeconds(30), // timeout
                Duration.ofSeconds(60) // recovery timeout
        );
    }

    public UserProfile getUserWithCircuitBreaker(String userId) {
        if (circuitBreaker.getState() == CircuitBreaker.State.OPEN) {
            throw new ServiceUnavailableException("Circuit breaker is OPEN");
        }

        try {
            UserProfile user = cache.get(userId, () -> {
                if (circuitBreaker.getState() == CircuitBreaker.State.HALF_OPEN) {
                    log.info("Circuit breaker in HALF_OPEN state, testing service");
                }

                return userService.loadUser(userId);
            });

            circuitBreaker.recordSuccess();
            return user;

        } catch (Exception e) {
            circuitBreaker.recordFailure();
            throw e;
        }
    }

    public CircuitBreaker.State getCircuitBreakerState() {
        return circuitBreaker.getState();
    }
}

// Fallback Strategies Implementation
class FallbackCacheService {
    private final Cache<String, UserProfile> primaryCache;
    private final Cache<String, UserProfile> fallbackCache;

    public FallbackCacheService() {
        this.primaryCache = JCacheXBuilder.forReadHeavyWorkload()
                .name("primary-users")
                .maximumSize(10000L)
                .expireAfterWrite(Duration.ofMinutes(30))
                .build();

        this.fallbackCache = JCacheXBuilder.forMemoryConstrainedEnvironment()
                .name("fallback-users")
                .maximumSize(1000L)
                .expireAfterWrite(Duration.ofHours(2))
                .build();
    }

    public UserProfile getUserWithFallback(String userId) {
        try {
            // Try primary cache first
            return primaryCache.get(userId, () -> {
                UserProfile user = userService.loadUser(userId);
                // Store in fallback cache for future use
                fallbackCache.put(userId, user);
                return user;
            });

        } catch (ServiceUnavailableException e) {
            log.warning("Primary service unavailable for {}, trying fallback", userId);
            return getFallbackUser(userId);

        } catch (TimeoutException e) {
            log.warning("Primary service timeout for {}, trying fallback", userId);
            return getFallbackUser(userId);

        } catch (Exception e) {
            log.error("Unexpected error for {}: {}", userId, e.getMessage());
            return getFallbackUser(userId);
        }
    }

    private UserProfile getFallbackUser(String userId) {
        // Try fallback cache
        UserProfile fallbackUser = fallbackCache.getIfPresent(userId);
        if (fallbackUser != null) {
            fallbackUser.setSource("fallback-cache");
            return fallbackUser;
        }

        // Last resort: return default user
        return createDefaultUser(userId);
    }

    private UserProfile createDefaultUser(String userId) {
        UserProfile defaultUser = new UserProfile(userId, "Unknown User", "unknown@example.com");
        defaultUser.setSource("default");
        return defaultUser;
    }
}

// Graceful Degradation Implementation
class GracefulDegradationService {
    private final Cache<String, UserProfile> cache;
    private boolean notificationServiceAvailable = true;
    private boolean analyticsServiceAvailable = true;
    private boolean recommendationServiceAvailable = true;

    public GracefulDegradationService() {
        this.cache = JCacheXBuilder.forReadHeavyWorkload()
                .name("graceful-users")
                .maximumSize(5000L)
                .expireAfterWrite(Duration.ofMinutes(20))
                .build();
    }

    public void processUserRequest(String userId) {
        try {
            // Essential: User data (always required)
            UserProfile user = cache.get(userId, () -> userService.loadUser(userId));
            System.out.println("✅ Core: User data loaded for " + user.getName());

            // Optional: Notifications (graceful degradation)
            if (notificationServiceAvailable) {
                try {
                    notificationService.sendWelcomeNotification(userId);
                    System.out.println("✅ Optional: Welcome notification sent");
                } catch (Exception e) {
                    log.warning("Notification service failed, continuing without notifications");
                    notificationServiceAvailable = false;
                }
            } else {
                System.out.println("⚠️  Optional: Notifications disabled (service unavailable)");
            }

            // Optional: Analytics tracking (graceful degradation)
            if (analyticsServiceAvailable) {
                try {
                    trackUserActivity(userId);
                    System.out.println("✅ Optional: User activity tracked");
                } catch (Exception e) {
                    log.warning("Analytics service failed, continuing without tracking");
                    analyticsServiceAvailable = false;
                }
            } else {
                System.out.println("⚠️  Optional: Analytics disabled (service unavailable)");
            }

            // Optional: Recommendations (graceful degradation)
            if (recommendationServiceAvailable) {
                try {
                    loadRecommendations(userId);
                    System.out.println("✅ Optional: Recommendations loaded");
                } catch (Exception e) {
                    log.warning("Recommendation service failed, continuing without recommendations");
                    recommendationServiceAvailable = false;
                }
            } else {
                System.out.println("⚠️  Optional: Recommendations disabled (service unavailable)");
            }

        } catch (Exception e) {
            log.error("Critical error processing user request: {}", e.getMessage());
            throw new RuntimeException("Essential service failed", e);
        }
    }

    public void simulateNotificationFailure() {
        this.notificationServiceAvailable = false;
    }

    public void simulateMultipleFailures() {
        this.notificationServiceAvailable = false;
        this.analyticsServiceAvailable = false;
        this.recommendationServiceAvailable = false;
    }

    private void trackUserActivity(String userId) {
        // Simulate analytics tracking
        if (Math.random() < 0.1) { // 10% failure rate
            throw new RuntimeException("Analytics service unavailable");
        }
    }

    private void loadRecommendations(String userId) {
        // Simulate recommendation loading
        if (Math.random() < 0.15) { // 15% failure rate
            throw new RuntimeException("Recommendation service unavailable");
        }
    }
}

// Monitoring Integration Implementation
class MonitoringIntegratedCache {
    private final Cache<String, String> cache;
    private final MetricsService metrics;

    public MonitoringIntegratedCache() {
        this.cache = JCacheXBuilder.forReadHeavyWorkload()
                .name("monitored-cache")
                .maximumSize(1000L)
                .expireAfterWrite(Duration.ofMinutes(10))
                .recordStats(true)
                .evictionListener(this::onEviction)
                .build();

        this.metrics = new MetricsService();
    }

    public String getDataWithMonitoring(String key) {
        long startTime = System.nanoTime();

        try {
            String data = cache.get(key, () -> {
                // Simulate data loading
                Thread.sleep(ThreadLocalRandom.current().nextInt(10, 100));
                return "Data for " + key;
            });

            long endTime = System.nanoTime();
            metrics.recordSuccess("cache_get", endTime - startTime);

            return data;

        } catch (Exception e) {
            long endTime = System.nanoTime();
            metrics.recordFailure("cache_get", endTime - startTime);

            // Send alert for repeated failures
            if (metrics.getFailureRate("cache_get") > 0.1) { // 10% failure rate threshold
                sendAlert("High cache failure rate detected: " + metrics.getFailureRate("cache_get"));
            }

            throw e;
        }
    }

    private void onEviction(String key, String value, RemovalCause cause) {
        metrics.recordEviction("cache_eviction", cause.name());

        // Alert on unexpected evictions
        if (cause == RemovalCause.SIZE && metrics.getEvictionRate() > 0.2) {
            sendAlert("High eviction rate detected, consider increasing cache size");
        }
    }

    private void sendAlert(String message) {
        log.warning("ALERT: " + message);
        // In production: send to alerting system (PagerDuty, Slack, etc.)
    }

    public void printMonitoringStats() {
        CacheStats stats = cache.stats();
        System.out.println("Cache Statistics:");
        System.out.printf("  Hit Rate: %.2f%%\n", stats.hitRate() * 100);
        System.out.printf("  Miss Rate: %.2f%%\n", stats.missRate() * 100);
        System.out.printf("  Eviction Count: %d\n", stats.evictionCount());
        System.out.printf("  Average Load Time: %.2fms\n", stats.averageLoadPenalty() / 1_000_000.0);

        System.out.println("\nApplication Metrics:");
        System.out.printf("  Success Rate: %.2f%%\n", (1 - metrics.getFailureRate("cache_get")) * 100);
        System.out.printf("  Failure Rate: %.2f%%\n", metrics.getFailureRate("cache_get") * 100);
        System.out.printf("  Eviction Rate: %.2f%%\n", metrics.getEvictionRate() * 100);
    }
}

// Supporting classes and utilities
class UserProfile {
    private final String id;
    private final String name;
    private final String email;
    private String source = "primary";

    public UserProfile(String id, String name, String email) {
        this.id = id;
        this.name = name;
        this.email = email;
    }

    public String getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public String getEmail() {
        return email;
    }

    public String getSource() {
        return source;
    }

    public void setSource(String source) {
        this.source = source;
    }
}

class UserService {
    public UserProfile loadUser(String userId) {
        // Simulate network latency
        try {
            Thread.sleep(ThreadLocalRandom.current().nextInt(10, 50));
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }

        // Simulate failures
        if (userId.contains("unavailable")) {
            throw new ServiceUnavailableException("User service temporarily unavailable");
        }
        if (userId.contains("timeout")) {
            throw new TimeoutException("User service timeout");
        }

        return new UserProfile(userId, "User " + userId, userId + "@example.com");
    }
}

class NotificationService {
    public void sendWelcomeNotification(String userId) {
        // Simulate notification sending
        if (Math.random() < 0.2) { // 20% failure rate
            throw new RuntimeException("Notification service failed");
        }
    }
}

class MetricsService {
    private int successCount = 0;
    private int failureCount = 0;
    private int evictionCount = 0;

    public void recordSuccess(String operation, long duration) {
        successCount++;
        // In production: send to metrics system
    }

    public void recordFailure(String operation, long duration) {
        failureCount++;
        // In production: send to metrics system
    }

    public void recordEviction(String operation, String cause) {
        evictionCount++;
        // In production: send to metrics system
    }

    public double getFailureRate(String operation) {
        int total = successCount + failureCount;
        return total > 0 ? (double) failureCount / total : 0.0;
    }

    public double getEvictionRate() {
        int total = successCount + failureCount;
        return total > 0 ? (double) evictionCount / total : 0.0;
    }
}

// Custom exceptions
class ServiceUnavailableException extends RuntimeException {
    public ServiceUnavailableException(String message) {
        super(message);
    }
}

class TimeoutException extends RuntimeException {
    public TimeoutException(String message) {
        super(message);
    }
}

// Circuit Breaker Implementation
class CircuitBreaker {
    public enum State {
        CLOSED, OPEN, HALF_OPEN
    }

    private final int failureThreshold;
    private final Duration timeout;
    private final Duration recoveryTimeout;

    private State state = State.CLOSED;
    private int failureCount = 0;
    private Instant lastFailureTime;

    public CircuitBreaker(int failureThreshold, Duration timeout, Duration recoveryTimeout) {
        this.failureThreshold = failureThreshold;
        this.timeout = timeout;
        this.recoveryTimeout = recoveryTimeout;
    }

    public void recordSuccess() {
        this.failureCount = 0;
        this.state = State.CLOSED;
    }

    public void recordFailure() {
        this.failureCount++;
        this.lastFailureTime = Instant.now();

        if (failureCount >= failureThreshold) {
            this.state = State.OPEN;
        }
    }

    public State getState() {
        if (state == State.OPEN && lastFailureTime != null) {
            if (Duration.between(lastFailureTime, Instant.now()).compareTo(recoveryTimeout) > 0) {
                state = State.HALF_OPEN;
            }
        }
        return state;
    }
}
`;

export const FIVE_MINUTE_POWER_EXAMPLE = `import io.github.dhruv1110.jcachex.*;
import java.time.Duration;

public class FiveMinutePower {
    public static void main(String[] args) {
        // Show the "magic" of profiles - ONE line gives optimal config
        Cache<String, Product> productCache = JCacheXBuilder
                .forReadHeavyWorkload() // Automatically optimized for read-heavy patterns
                .name("products")
                .maximumSize(10000L)
                .build();

        // Results: 11.5ns GET performance automatically configured!
        // No complex tuning needed - the profile handles it

        // Simulate loading products
        for (int i = 1; i <= 100; i++) {
            productCache.put("product" + i, new Product("Product " + i, 99.99 + i));
        }

        // Lightning-fast retrieval
        long startTime = System.nanoTime();
        Product product = productCache.get("product42");
        long endTime = System.nanoTime();

        System.out.println("✅ Retrieved product: " + product.getName());
        System.out.println("⚡ Time taken: " + (endTime - startTime) + "ns");
        System.out.println("🎯 Hit rate: " + String.format("%.2f%%", productCache.stats().hitRate() * 100));

        // Different workload? Just change the profile!
        Cache<String, Session> sessionCache = JCacheXBuilder
                .forWriteHeavyWorkload() // Optimized for frequent writes
                .name("sessions")
                .maximumSize(5000L)
                .expireAfterWrite(Duration.ofMinutes(30))
                .build();

        System.out.println("✅ Multiple optimized caches created with zero complexity!");
    }

    // Simple product class for demonstration
    static class Product {
        private String name;
        private double price;

        public Product(String name, double price) {
            this.name = name;
            this.price = price;
        }

        public String getName() {
            return name;
        }

        public double getPrice() {
            return price;
        }
    }

    // Simple session class for demonstration
    static class Session {
        private String userId;
        private long lastAccess;

        public Session(String userId) {
            this.userId = userId;
            this.lastAccess = System.currentTimeMillis();
        }

        public String getUserId() {
            return userId;
        }

        public long getLastAccess() {
            return lastAccess;
        }
    }
}
`;

export const MICROSERVICES_API_GATEWAY_EXAMPLE = `import io.github.dhruv1110.jcachex.*;
import java.time.Duration;
import java.time.Instant;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ThreadLocalRandom;
import java.util.logging.Logger;

/**
 * Microservices API Gateway with Intelligent Caching
 * Demonstrates how to implement high-performance API response caching
 * with circuit breaker patterns and intelligent TTL strategies
 */
public class MicroservicesApiGateway {
    private static final Logger log = Logger.getLogger(MicroservicesApiGateway.class.getName());

    // Multi-layer caching strategy for different data types
    private final Cache<String, ApiResponse> responseCache;
    private final Cache<String, UserProfile> userProfileCache;
    private final Cache<String, ServiceHealth> healthCache;

    // Simulated downstream services
    private final UserService userService = new UserService();
    private final ProductService productService = new ProductService();
    private final OrderService orderService = new OrderService();

    public MicroservicesApiGateway() {
        // API response cache with short TTL for dynamic content
        this.responseCache = JCacheXBuilder.forApiResponseCaching()
                .name("api-responses")
                .maximumSize(50000L)
                .expireAfterWrite(Duration.ofMinutes(5)) // Short TTL for API responses
                .expireAfterAccess(Duration.ofMinutes(10)) // Keep frequently accessed longer
                .recordStats(true)
                .evictionListener(this::onResponseEviction)
                .build();

        // User profile cache with longer TTL (user data changes less frequently)
        this.userProfileCache = JCacheXBuilder.forReadHeavyWorkload()
                .name("user-profiles")
                .maximumSize(100000L)
                .expireAfterWrite(Duration.ofHours(1))
                .expireAfterAccess(Duration.ofHours(2))
                .recordStats(true)
                .build();

        // Service health cache for monitoring
        this.healthCache = JCacheXBuilder.forWriteHeavyWorkload()
                .name("service-health")
                .maximumSize(1000L)
                .expireAfterWrite(Duration.ofSeconds(30))
                .recordStats(true)
                .build();
    }

    /**
     * Gateway endpoint: GET /api/users/{id}
     * Demonstrates intelligent caching with fallback strategies
     */
    public ApiResponse getUser(String userId) {
        String cacheKey = "user:" + userId;

        return responseCache.get(cacheKey, () -> {
            try {
                // Check service health first
                if (!isServiceHealthy("user-service")) {
                    return getStaleUserResponse(userId);
                }

                // Call downstream service
                UserProfile user = userService.fetchUser(userId);

                // Cache the user profile separately for other endpoints
                userProfileCache.put(userId, user);

                // Return API response with metadata
                return new ApiResponse(
                        user,
                        Instant.now(),
                        "user-service",
                        CacheStatus.MISS);

            } catch (ServiceUnavailableException e) {
                log.warning("User service unavailable for user " + userId);
                return getStaleUserResponse(userId);

            } catch (TimeoutException e) {
                log.error("Timeout fetching user " + userId, e);
                throw new CacheLoadException("User service timeout", e);
            }
        });
    }

    /**
     * Gateway endpoint: GET /api/products/{id}
     * Demonstrates circuit breaker pattern with caching
     */
    public ApiResponse getProduct(String productId) {
        String cacheKey = "product:" + productId;

        return responseCache.get(cacheKey, () -> {
            // Circuit breaker check
            if (!isServiceHealthy("product-service")) {
                throw new ServiceUnavailableException("Product service circuit breaker open");
            }

            try {
                Product product = productService.fetchProduct(productId);

                return new ApiResponse(
                        product,
                        Instant.now(),
                        "product-service",
                        CacheStatus.MISS);

            } catch (Exception e) {
                // Update service health
                updateServiceHealth("product-service", false);
                throw e;
            }
        });
    }

    /**
     * Gateway endpoint: GET /api/orders/{id}
     * Demonstrates conditional caching based on data sensitivity
     */
    public ApiResponse getOrder(String orderId, String userId) {
        // Orders are user-specific and sensitive - include user in cache key
        String cacheKey = "order:" + orderId + ":" + userId;

        return responseCache.get(cacheKey, () -> {
            // Verify user has access to this order
            if (!orderService.canUserAccessOrder(userId, orderId)) {
                throw new UnauthorizedException("User cannot access order");
            }

            Order order = orderService.fetchOrder(orderId);

            return new ApiResponse(
                    order,
                    Instant.now(),
                    "order-service",
                    CacheStatus.MISS);
        });
    }

    /**
     * Asynchronous cache warming for popular endpoints
     */
    public CompletableFuture<Void> warmCache(String[] popularUserIds) {
        return CompletableFuture.runAsync(() -> {
            log.info("Starting cache warming for {} users", popularUserIds.length);

            for (String userId : popularUserIds) {
                try {
                    // Pre-load user data
                    getUser(userId);

                    // Small delay to avoid overwhelming downstream services
                    Thread.sleep(10);

                } catch (Exception e) {
                    log.warning("Failed to warm cache for user " + userId + ": " + e.getMessage());
                }
            }

            log.info("Cache warming completed");
        });
    }

    /**
     * Circuit breaker health check
     */
    private boolean isServiceHealthy(String serviceName) {
        ServiceHealth health = healthCache.getIfPresent(serviceName);
        if (health == null) {
            // Assume healthy if no recent data
            updateServiceHealth(serviceName, true);
            return true;
        }
        return health.isHealthy();
    }

    /**
     * Update service health status
     */
    private void updateServiceHealth(String serviceName, boolean isHealthy) {
        ServiceHealth health = new ServiceHealth(serviceName, isHealthy, Instant.now());
        healthCache.put(serviceName, health);

        if (!isHealthy) {
            log.warning("Service {} marked as unhealthy", serviceName);
        }
    }

    /**
     * Fallback to stale data when service is unavailable
     */
    private ApiResponse getStaleUserResponse(String userId) {
        UserProfile staleUser = userProfileCache.getIfPresent(userId);
        if (staleUser != null) {
            log.info("Returning stale user data for {}", userId);
            return new ApiResponse(
                    staleUser,
                    Instant.now(),
                    "user-service",
                    CacheStatus.STALE);
        }

        // Return default response as last resort
        return new ApiResponse(
                new UserProfile(userId, "Unknown User", "unknown@example.com"),
                Instant.now(),
                "user-service",
                CacheStatus.DEFAULT);
    }

    /**
     * Cache eviction listener for monitoring
     */
    private void onResponseEviction(String key, ApiResponse response, RemovalCause cause) {
        log.info("API response evicted: {} (from {}) due to {}",
                key, response.getServiceName(), cause);

        // In production, send metrics to monitoring system
        // Examples: Prometheus, Grafana, CloudWatch
    }

    /**
     * Get comprehensive gateway statistics
     */
    public void printGatewayStats() {
        System.out.println("🌐 API Gateway Cache Statistics");
        System.out.println("================================");

        // Response cache stats
        CacheStats responseStats = responseCache.stats();
        System.out.printf("Response Cache - Size: %d, Hit Rate: %.2f%%, Avg Load: %.2fms%n",
                responseCache.size(),
                responseStats.hitRate() * 100,
                responseStats.averageLoadPenalty() / 1_000_000.0);

        // User profile cache stats
        CacheStats userStats = userProfileCache.stats();
        System.out.printf("User Profile Cache - Size: %d, Hit Rate: %.2f%%%n",
                userProfileCache.size(), userStats.hitRate() * 100);

        // Health cache stats
        CacheStats healthStats = healthCache.stats();
        System.out.printf("Health Cache - Size: %d, Hit Rate: %.2f%%%n",
                healthCache.size(), healthStats.hitRate() * 100);

        // Service health status
        System.out.println("\n🏥 Service Health Status:");
        String[] services = { "user-service", "product-service", "order-service" };
        for (String service : services) {
            ServiceHealth health = healthCache.getIfPresent(service);
            String status = health != null ? (health.isHealthy() ? "✅ Healthy" : "❌ Unhealthy") : "❓ Unknown";
            System.out.printf("  %s: %s%n", service, status);
        }
    }

    // Demo method
    public static void main(String[] args) throws InterruptedException {
        MicroservicesApiGateway gateway = new MicroservicesApiGateway();

        System.out.println("🚪 Microservices API Gateway Demo");
        System.out.println("===================================");

        // 1. Fresh requests (cache misses)
        System.out.println("\n1. Fresh API requests:");
        ApiResponse userResponse = gateway.getUser("user123");
        System.out.println("   User response: " + userResponse.getData());

        ApiResponse productResponse = gateway.getProduct("prod456");
        System.out.println("   Product response: " + productResponse.getData());

        // 2. Repeated requests (cache hits)
        System.out.println("\n2. Repeated requests (cache hits):");
        gateway.getUser("user123");
        gateway.getProduct("prod456");
        System.out.println("   Requests served from cache");

        // 3. Cache warming
        System.out.println("\n3. Cache warming:");
        String[] popularUsers = { "user1", "user2", "user3", "user4", "user5" };
        gateway.warmCache(popularUsers).get();
        System.out.println("   Cache warming completed");

        // 4. Simulate service failure
        System.out.println("\n4. Service failure simulation:");
        gateway.updateServiceHealth("user-service", false);
        ApiResponse staleResponse = gateway.getUser("user123");
        System.out.println("   Stale response status: " + staleResponse.getCacheStatus());

        // 5. Show gateway statistics
        System.out.println("\n5. Gateway performance:");
        gateway.printGatewayStats();

        System.out.println("\n✅ API Gateway demo completed!");
    }
}

// Supporting classes
class ApiResponse {
    private final Object data;
    private final Instant timestamp;
    private final String serviceName;
    private final CacheStatus cacheStatus;

    public ApiResponse(Object data, Instant timestamp, String serviceName, CacheStatus cacheStatus) {
        this.data = data;
        this.timestamp = timestamp;
        this.serviceName = serviceName;
        this.cacheStatus = cacheStatus;
    }

    public Object getData() {
        return data;
    }

    public Instant getTimestamp() {
        return timestamp;
    }

    public String getServiceName() {
        return serviceName;
    }

    public CacheStatus getCacheStatus() {
        return cacheStatus;
    }
}

enum CacheStatus {
    HIT, MISS, STALE, DEFAULT
}

class UserProfile {
    private final String id;
    private final String name;
    private final String email;

    public UserProfile(String id, String name, String email) {
        this.id = id;
        this.name = name;
        this.email = email;
    }

    public String getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public String getEmail() {
        return email;
    }

    @Override
    public String toString() {
        return String.format("UserProfile{id='%s', name='%s'}", id, name);
    }
}

class Product {
    private final String id;
    private final String name;
    private final double price;

    public Product(String id, String name, double price) {
        this.id = id;
        this.name = name;
        this.price = price;
    }

    public String getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public double getPrice() {
        return price;
    }

    @Override
    public String toString() {
        return String.format("Product{id='%s', name='%s', price=%.2f}", id, name, price);
    }
}

class Order {
    private final String id;
    private final String userId;
    private final double total;

    public Order(String id, String userId, double total) {
        this.id = id;
        this.userId = userId;
        this.total = total;
    }

    public String getId() {
        return id;
    }

    public String getUserId() {
        return userId;
    }

    public double getTotal() {
        return total;
    }

    @Override
    public String toString() {
        return String.format("Order{id='%s', userId='%s', total=%.2f}", id, userId, total);
    }
}

class ServiceHealth {
    private final String serviceName;
    private final boolean healthy;
    private final Instant lastCheck;

    public ServiceHealth(String serviceName, boolean healthy, Instant lastCheck) {
        this.serviceName = serviceName;
        this.healthy = healthy;
        this.lastCheck = lastCheck;
    }

    public String getServiceName() {
        return serviceName;
    }

    public boolean isHealthy() {
        return healthy;
    }

    public Instant getLastCheck() {
        return lastCheck;
    }
}

// Simulated downstream services
class UserService {
    public UserProfile fetchUser(String userId) throws ServiceUnavailableException {
        simulateNetworkLatency();

        if (ThreadLocalRandom.current().nextDouble() < 0.05) { // 5% failure rate
            throw new ServiceUnavailableException("User service temporarily unavailable");
        }

        return new UserProfile(userId, "User " + userId, userId + "@example.com");
    }

    private void simulateNetworkLatency() {
        try {
            Thread.sleep(ThreadLocalRandom.current().nextInt(10, 50));
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
}

class ProductService {
    public Product fetchProduct(String productId) throws ServiceUnavailableException {
        simulateNetworkLatency();

        if (ThreadLocalRandom.current().nextDouble() < 0.03) { // 3% failure rate
            throw new ServiceUnavailableException("Product service temporarily unavailable");
        }

        return new Product(productId, "Product " + productId, 99.99);
    }

    private void simulateNetworkLatency() {
        try {
            Thread.sleep(ThreadLocalRandom.current().nextInt(15, 75));
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
}

class OrderService {
    public Order fetchOrder(String orderId) throws ServiceUnavailableException {
        simulateNetworkLatency();
        return new Order(orderId, "user123", 299.99);
    }

    public boolean canUserAccessOrder(String userId, String orderId) {
        // Simplified authorization check
        return userId != null && orderId != null;
    }

    private void simulateNetworkLatency() {
        try {
            Thread.sleep(ThreadLocalRandom.current().nextInt(20, 100));
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
}

// Custom exceptions
class ServiceUnavailableException extends RuntimeException {
    public ServiceUnavailableException(String message) {
        super(message);
    }
}

class TimeoutException extends RuntimeException {
    public TimeoutException(String message) {
        super(message);
    }
}

class UnauthorizedException extends RuntimeException {
    public UnauthorizedException(String message) {
        super(message);
    }
}

class CacheLoadException extends RuntimeException {
    public CacheLoadException(String message, Throwable cause) {
        super(message, cause);
    }
}
`;

export const MULTI_CACHE_SYSTEM_EXAMPLE = `import io.github.dhruv1110.jcachex.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.time.Duration;
import java.util.*;

public class MultiCacheManager {
    private final ConcurrentMap<String, Cache<?, ?>> cacheRegistry;
    private final CacheConfig<?> defaultConfig;

    public MultiCacheManager() {
        this.cacheRegistry = new ConcurrentHashMap<>();
        this.defaultConfig = CacheConfig.builder()
                .maximumSize(1000L)
                .expireAfterWrite(Duration.ofMinutes(30))
                .recordStats(true)
                .build();
    }

    // Create specialized caches for different domains
    public void initializeCaches() {
        // User cache - frequently accessed, longer TTL
        Cache<String, User> userCache = createCache(
                "users",
                CacheConfig.<String, User>builder()
                        .maximumSize(5000L)
                        .expireAfterWrite(Duration.ofHours(4))
                        .evictionStrategy(EvictionStrategy.LRU)
                        .recordStats(true)
                        .build());

        // Session cache - short TTL, high volume
        Cache<String, Session> sessionCache = createCache(
                "sessions",
                CacheConfig.<String, Session>builder()
                        .maximumSize(10000L)
                        .expireAfterWrite(Duration.ofMinutes(30))
                        .expireAfterAccess(Duration.ofMinutes(15))
                        .evictionStrategy(EvictionStrategy.LRU)
                        .recordStats(true)
                        .build());

        // Product cache - large objects, weight-based eviction
        Cache<String, Product> productCache = createCache(
                "products",
                CacheConfig.<String, Product>builder()
                        .maximumSize(2000L)
                        .maximumWeight(50 * 1024 * 1024) // 50MB
                        .expireAfterWrite(Duration.ofHours(12))
                        .evictionStrategy(EvictionStrategy.LRU)
                        .weigher((key, value) -> key.length() + estimateProductSize(value))
                        .recordStats(true)
                        .build());

        // Configuration cache - rarely changes, very long TTL
        Cache<String, String> configCache = createCache(
                "config",
                CacheConfig.<String, String>builder()
                        .maximumSize(500L)
                        .expireAfterWrite(Duration.ofDays(1))
                        .recordStats(true)
                        .build());
    }

    @SuppressWarnings("unchecked")
    private <K, V> Cache<K, V> createCache(String name, CacheConfig<K, V> config) {
        Cache<K, V> cache = new DefaultCache<>(config);
        cacheRegistry.put(name, cache);
        return cache;
    }

    @SuppressWarnings("unchecked")
    public <K, V> Cache<K, V> getCache(String name) {
        return (Cache<K, V>) cacheRegistry.get(name);
    }

    // Coordinated cache operations
    public void invalidateUser(String userId) {
        // Invalidate across multiple caches
        Cache<String, User> userCache = getCache("users");
        Cache<String, Session> sessionCache = getCache("sessions");

        userCache.invalidate(userId);

        // Invalidate all sessions for this user
        sessionCache.asMap().entrySet().removeIf(entry -> {
            Session session = entry.getValue();
            return session.getUserId().equals(userId);
        });
    }

    // Cache warming strategy
    public void warmCaches() {
        // Warm user cache with VIP users
        Cache<String, User> userCache = getCache("users");
        List<User> vipUsers = loadVipUsers(); // Load from database
        vipUsers.forEach(user -> userCache.put(user.getId(), user));

        // Warm product cache with featured products
        Cache<String, Product> productCache = getCache("products");
        List<Product> featuredProducts = loadFeaturedProducts();
        featuredProducts.forEach(product -> productCache.put(product.getId(), product));

        // Warm config cache
        Cache<String, String> configCache = getCache("config");
        Map<String, String> configs = loadConfigurations();
        configCache.putAll(configs);
    }

    // Unified cache statistics
    public CacheSystemStats getSystemStats() {
        Map<String, CacheStats> allStats = new HashMap<>();
        long totalSize = 0;
        double totalHitRate = 0;

        for (Map.Entry<String, Cache<?, ?>> entry : cacheRegistry.entrySet()) {
            String cacheName = entry.getKey();
            Cache<?, ?> cache = entry.getValue();
            CacheStats stats = cache.stats();

            allStats.put(cacheName, stats);
            totalSize += cache.size();
            totalHitRate += stats.hitRate();
        }

        return new CacheSystemStats(
                allStats,
                totalSize,
                totalHitRate / cacheRegistry.size());
    }

    // Graceful shutdown
    public void shutdown() {
        cacheRegistry.values().forEach(cache -> {
            // Perform cleanup if needed
            cache.invalidateAll();
        });
        cacheRegistry.clear();
    }

    private int estimateProductSize(Product product) {
        // Estimate memory footprint
        return product.getName().length() * 2 +
                product.getDescription().length() * 2 +
                100; // Base object size
    }

    private List<User> loadVipUsers() {
        // Load VIP users from database
        return Arrays.asList(
                new User("vip1", "VIP User 1", "vip1@example.com"),
                new User("vip2", "VIP User 2", "vip2@example.com"));
    }

    private List<Product> loadFeaturedProducts() {
        // Load featured products from database
        return Arrays.asList(
                new Product("featured1", "Featured Product 1", "Description 1"),
                new Product("featured2", "Featured Product 2", "Description 2"));
    }

    private Map<String, String> loadConfigurations() {
        // Load system configurations
        return Map.of(
                "app.name", "JCacheX Example",
                "app.version", "1.0.0",
                "feature.enabled", "true");
    }
}
`;

export const OBJECT_CACHING_EXAMPLE = `import io.github.dhruv1110.jcachex.*;
import java.time.Duration;
import java.time.LocalDateTime;

// Domain object for caching
public class UserProfile {
    private final String userId;
    private final String name;
    private final String email;
    private final LocalDateTime lastLogin;

    public UserProfile(String userId, String name, String email, LocalDateTime lastLogin) {
        this.userId = userId;
        this.name = name;
        this.email = email;
        this.lastLogin = lastLogin;
    }

    // Getters
    public String getUserId() {
        return userId;
    }

    public String getName() {
        return name;
    }

    public String getEmail() {
        return email;
    }

    public LocalDateTime getLastLogin() {
        return lastLogin;
    }

    @Override
    public String toString() {
        return String.format("UserProfile{userId='%s', name='%s', email='%s', lastLogin=%s}",
                userId, name, email, lastLogin);
    }
}

public class ObjectCacheExample {
    public static void main(String[] args) {
        // Configure cache for user profiles
        CacheConfig<String, UserProfile> config = CacheConfig.<String, UserProfile>builder()
                .maximumSize(500L)
                .expireAfterWrite(Duration.ofHours(4))
                .evictionStrategy(EvictionStrategy.LRU)
                .recordStats(true)
                .build();

        Cache<String, UserProfile> userCache = new DefaultCache<>(config);

        // Create and cache user profiles
        UserProfile user1 = new UserProfile("123", "Alice Johnson", "alice@example.com", LocalDateTime.now());
        UserProfile user2 = new UserProfile("456", "Bob Wilson", "bob@example.com", LocalDateTime.now().minusHours(2));

        userCache.put(user1.getUserId(), user1);
        userCache.put(user2.getUserId(), user2);

        // Retrieve cached objects
        UserProfile cachedUser = userCache.get("123");
        if (cachedUser != null) {
            System.out.println("Retrieved user: " + cachedUser);
        }

        // Batch operations
        Map<String, UserProfile> batch = Map.of(
                "789", new UserProfile("789", "Charlie Brown", "charlie@example.com", LocalDateTime.now()),
                "101",
                new UserProfile("101", "Diana Prince", "diana@example.com", LocalDateTime.now().minusMinutes(30)));

        userCache.putAll(batch);

        // Performance monitoring
        CacheStats stats = userCache.stats();
        System.out.println("Cache performance:");
        System.out.println("  Requests: " + stats.requestCount());
        System.out.println("  Hits: " + stats.hitCount());
        System.out.println("  Misses: " + stats.missCount());
        System.out.println("  Hit rate: " + String.format("%.2f%%", stats.hitRate() * 100));
    }
}
`;

export const OBSERVABLE_CACHE_SERVICE_EXAMPLE = `import io.github.dhruv1110.jcachex.*;
import io.micrometer.core.instrument.MeterRegistry;
import io.micrometer.core.instrument.Timer;
import io.micrometer.core.instrument.Counter;
import io.micrometer.core.instrument.Gauge;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.Executors;
import java.time.Duration;
import java.time.Instant;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.slf4j.MDC;

public class ObservableCacheService {
    private static final Logger logger = LoggerFactory.getLogger(ObservableCacheService.class);
    private final Cache<String, String> cache;
    private final MeterRegistry meterRegistry;
    private final Timer cacheLoadTimer;
    private final Counter cacheHitCounter;
    private final Counter cacheMissCounter;
    private final ScheduledExecutorService scheduler;
    private final AlertService alertService;

    public ObservableCacheService(MeterRegistry meterRegistry, AlertService alertService) {
        this.meterRegistry = meterRegistry;
        this.alertService = alertService;
        this.scheduler = Executors.newScheduledThreadPool(1);

        // Configure cache with observability
        CacheConfig<String, String> config = CacheConfig.<String, String>builder()
                .maximumSize(1000L)
                .expireAfterWrite(Duration.ofMinutes(30))
                .recordStats(true)
                .eventListener(new ObservabilityCacheEventListener())
                .build();

        this.cache = new DefaultCache<>(config);

        // Initialize metrics
        this.cacheLoadTimer = Timer.builder("cache.load.time")
                .description("Time taken to load cache values")
                .register(meterRegistry);

        this.cacheHitCounter = Counter.builder("cache.hits")
                .description("Number of cache hits")
                .register(meterRegistry);

        this.cacheMissCounter = Counter.builder("cache.misses")
                .description("Number of cache misses")
                .register(meterRegistry);

        // Register cache size gauge
        Gauge.builder("cache.size")
                .description("Current cache size")
                .register(meterRegistry, cache, Cache::size);

        // Register hit rate gauge
        Gauge.builder("cache.hit_rate")
                .description("Cache hit rate")
                .register(meterRegistry, cache, c -> c.stats().hitRate());

        // Start periodic metrics collection
        startMetricsCollection();
    }

    public String getValue(String key) {
        String value = cache.get(key);

        if (value != null) {
            cacheHitCounter.increment();
            return value;
        }

        cacheMissCounter.increment();

        // Load with timing
        Timer.Sample sample = Timer.start(meterRegistry);
        try {
            value = loadValue(key);
            cache.put(key, value);
            return value;
        } finally {
            sample.stop(cacheLoadTimer);
        }
    }

    private String loadValue(String key) {
        // Simulate expensive operation
        try {
            Thread.sleep(100);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            throw new RuntimeException(e);
        }
        return "loaded-" + key;
    }

    private void startMetricsCollection() {
        scheduler.scheduleAtFixedRate(() -> {
            CacheStats stats = cache.stats();

            // Custom metrics
            meterRegistry.gauge("cache.eviction_count", stats.evictionCount());
            meterRegistry.gauge("cache.load_exception_count", stats.loadExceptionCount());
            meterRegistry.gauge("cache.average_load_time", stats.averageLoadTime());

            // Log detailed metrics
            logCacheMetrics(stats);

            // Health checks
            performHealthChecks(stats);

        }, 0, 30, TimeUnit.SECONDS);
    }

    private void logCacheMetrics(CacheStats stats) {
        MDC.put("cache.size", String.valueOf(cache.size()));
        MDC.put("cache.hit_rate", String.format("%.2f", stats.hitRate()));
        MDC.put("cache.miss_rate", String.format("%.2f", stats.missRate()));
        MDC.put("cache.eviction_count", String.valueOf(stats.evictionCount()));

        logger.info("Cache metrics snapshot");

        MDC.clear();
    }

    private void performHealthChecks(CacheStats stats) {
        // Alert on low hit rate
        if (stats.hitRate() < 0.7) {
            alertService.sendAlert(
                    "Cache hit rate is low: " + String.format("%.2f%%", stats.hitRate() * 100),
                    AlertLevel.WARNING);
        }

        // Alert on high eviction rate
        long totalRequests = stats.requestCount();
        if (totalRequests > 0) {
            double evictionRate = (double) stats.evictionCount() / totalRequests;
            if (evictionRate > 0.1) {
                alertService.sendAlert(
                        "High cache eviction rate: " + String.format("%.2f%%", evictionRate * 100),
                        AlertLevel.WARNING);
            }
        }

        // Alert on slow load times
        if (stats.averageLoadTime() > 500) {
            alertService.sendAlert(
                    "Slow cache load time: " + stats.averageLoadTime() + "ms",
                    AlertLevel.WARNING);
        }
    }

    public CacheHealthReport generateHealthReport() {
        CacheStats stats = cache.stats();

        return CacheHealthReport.builder()
                .cacheSize(cache.size())
                .hitRate(stats.hitRate())
                .missRate(stats.missRate())
                .evictionCount(stats.evictionCount())
                .averageLoadTime(stats.averageLoadTime())
                .requestCount(stats.requestCount())
                .healthScore(calculateHealthScore(stats))
                .timestamp(Instant.now())
                .build();
    }

    private double calculateHealthScore(CacheStats stats) {
        double score = 1.0;

        // Penalize low hit rate
        if (stats.hitRate() < 0.5) {
            score -= 0.4;
        } else if (stats.hitRate() < 0.7) {
            score -= 0.2;
        }

        // Penalize slow load times
        if (stats.averageLoadTime() > 200) {
            score -= 0.2;
        }

        // Penalize high eviction rate
        long totalRequests = stats.requestCount();
        if (totalRequests > 0) {
            double evictionRate = (double) stats.evictionCount() / totalRequests;
            if (evictionRate > 0.05) {
                score -= 0.3;
            }
        }

        return Math.max(0, score);
    }

    private class ObservabilityCacheEventListener implements CacheEventListener<String, String> {
        @Override
        public void onEviction(String key, String value, EvictionReason reason) {
            meterRegistry.counter("cache.evictions", "reason", reason.toString()).increment();

            if (reason == EvictionReason.SIZE) {
                logger.warn("Cache size-based eviction for key: {}", key);
            }
        }

        @Override
        public void onRemoval(String key, String value, EvictionReason reason) {
            meterRegistry.counter("cache.removals", "reason", reason.toString()).increment();
        }
    }

    public void shutdown() {
        scheduler.shutdown();
        try {
            if (!scheduler.awaitTermination(5, TimeUnit.SECONDS)) {
                scheduler.shutdownNow();
            }
        } catch (InterruptedException e) {
            scheduler.shutdownNow();
            Thread.currentThread().interrupt();
        }
    }
}
`;

export const PRODUCTION_READY_EXAMPLE = `import io.github.dhruv1110.jcachex.*;
import java.time.Duration;
import java.util.logging.Logger;

public class ProductionReady {
    private static final Logger logger = Logger.getLogger(ProductionReady.class.getName());

    public static void main(String[] args) {
        // Complete production setup with monitoring and error handling
        Cache<String, User> userCache = createProductionUserCache();

        // Demonstrate production-ready usage
        demonstrateProductionUsage(userCache);

        // Show monitoring capabilities
        showMonitoringCapabilities(userCache);

        // Demonstrate error handling
        demonstrateErrorHandling(userCache);
    }

    private static Cache<String, User> createProductionUserCache() {
        return JCacheXBuilder.forReadHeavyWorkload()
                .name("users")
                .maximumSize(50000L)
                .expireAfterWrite(Duration.ofHours(2))
                .expireAfterAccess(Duration.ofHours(4))
                .recordStats(true)
                .evictionListener(ProductionReady::onEviction)
                .loadingCache(ProductionReady::loadUserFromDatabase)
                .build();
    }

    private static void demonstrateProductionUsage(Cache<String, User> cache) {
        System.out.println("🚀 Production Cache Demo");
        System.out.println("========================");

        // Simulate user access patterns
        String[] userIds = { "user1", "user2", "user3", "user1", "user2", "user1" };

        for (String userId : userIds) {
            long startTime = System.nanoTime();
            User user = cache.get(userId);
            long endTime = System.nanoTime();

            System.out.printf("✅ User %s retrieved in %dns: %s%n",
                    userId, (endTime - startTime), user.getName());
        }
    }

    private static void showMonitoringCapabilities(Cache<String, User> cache) {
        System.out.println("\n📊 Production Monitoring");
        System.out.println("========================");

        CacheStats stats = cache.stats();
        System.out.printf("Cache size: %d%n", cache.size());
        System.out.printf("Hit rate: %.2f%%%n", stats.hitRate() * 100);
        System.out.printf("Miss rate: %.2f%%%n", stats.missRate() * 100);
        System.out.printf("Eviction count: %d%n", stats.evictionCount());
        System.out.printf("Average load time: %.2fms%n", stats.averageLoadPenalty() / 1_000_000.0);
        System.out.printf("Total requests: %d%n", stats.requestCount());

        // In production, you would send these metrics to your monitoring system
        // Examples: Prometheus, Grafana, CloudWatch, etc.
    }

    private static void demonstrateErrorHandling(Cache<String, User> cache) {
        System.out.println("\n🛡️ Production Error Handling");
        System.out.println("=============================");

        try {
            // Simulate error scenarios
            User user = cache.get("error-user");
            System.out.println("✅ Error handling: " + user.getName());
        } catch (Exception e) {
            System.out.println("❌ Handled error gracefully: " + e.getMessage());

            // In production: log to centralized logging, send alerts, etc.
            logger.warning("Cache operation failed for user: error-user - " + e.getMessage());
        }
    }

    // Production-ready eviction listener
    private static void onEviction(String key, User user, RemovalCause cause) {
        logger.info(String.format("Evicted user %s (name: %s) due to %s",
                key, user != null ? user.getName() : "null", cause));

        // In production, you might:
        // 1. Log to centralized logging (ELK, Splunk, etc.)
        // 2. Send metrics to monitoring systems
        // 3. Trigger alerts for unexpected evictions
        // 4. Implement custom eviction handling logic
    }

    // Production-ready cache loader with error handling
    private static User loadUserFromDatabase(String userId) {
        // Simulate database call with realistic timing
        try {
            Thread.sleep(10); // Simulate DB latency

            if ("error-user".equals(userId)) {
                throw new RuntimeException("Database connection failed");
            }

            logger.info("Loading user " + userId + " from database");
            return new User(userId, "User " + userId, userId + "@example.com");

        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            throw new RuntimeException("Database load interrupted", e);
        }
    }

    // Production-ready User class
    static class User {
        private final String id;
        private final String name;
        private final String email;

        public User(String id, String name, String email) {
            this.id = id;
            this.name = name;
            this.email = email;
        }

        public String getId() {
            return id;
        }

        public String getName() {
            return name;
        }

        public String getEmail() {
            return email;
        }

        @Override
        public String toString() {
            return String.format("User{id='%s', name='%s', email='%s'}", id, name, email);
        }
    }
}
`;

export const THIRTY_SECOND_START_EXAMPLE = `import io.github.dhruv1110.jcachex.*;

public class ThirtySecondStart {
    public static void main(String[] args) {
        // Single line cache creation - show this FIRST
        Cache<String, String> cache = JCacheX.create().build();

        // Immediate success - put and get in 3 lines
        cache.put("user1", "Alice");
        String user = cache.get("user1"); // Alice retrieved instantly

        System.out.println("✅ Success! Retrieved user: " + user);

        // That's it! You now have a working cache
        // Ready for production with sensible defaults
    }
}
`;

export const THREAD_SAFETY_EXAMPLE = `import io.github.dhruv1110.jcachex.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.atomic.AtomicInteger;
import java.time.Duration;
import java.util.Map;

public class ThreadSafeCacheExample {
    private final Cache<String, String> cache;
    private final AtomicInteger hitCount = new AtomicInteger(0);
    private final AtomicInteger missCount = new AtomicInteger(0);

    public ThreadSafeCacheExample() {
        CacheConfig<String, String> config = CacheConfig.<String, String>builder()
                .maximumSize(1000L)
                .expireAfterWrite(Duration.ofMinutes(10))
                .recordStats(true)
                .build();

        this.cache = new DefaultCache<>(config);
    }

    // Thread-safe cache operations
    public String getOrLoad(String key) {
        String value = cache.get(key);
        if (value != null) {
            hitCount.incrementAndGet();
            return value;
        }

        // Atomic put-if-absent operation
        missCount.incrementAndGet();
        return cache.computeIfAbsent(key, k -> {
            // Simulate expensive computation
            return "computed-" + k + "-" + Thread.currentThread().getName();
        });
    }

    // Concurrent cache stress test
    public void stressTest(int numThreads, int operationsPerThread) throws InterruptedException {
        ExecutorService executor = Executors.newFixedThreadPool(numThreads);
        CountDownLatch latch = new CountDownLatch(numThreads);

        for (int i = 0; i < numThreads; i++) {
            final int threadId = i;
            executor.submit(() -> {
                try {
                    for (int j = 0; j < operationsPerThread; j++) {
                        String key = "key-" + (j % 100); // Overlapping keys
                        String value = getOrLoad(key);

                        // Simulate some work
                        Thread.sleep(1);

                        // Update cache
                        cache.put(key, "updated-" + threadId + "-" + j);
                    }
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                } finally {
                    latch.countDown();
                }
            });
        }

        latch.await();
        executor.shutdown();

        // Print results
        System.out.println("Stress test completed:");
        System.out.println("Cache size: " + cache.size());
        System.out.println("Hit count: " + hitCount.get());
        System.out.println("Miss count: " + missCount.get());
        System.out.println("Cache stats: " + cache.stats());
    }

    // Thread-safe bulk operations
    public void bulkUpdate(Map<String, String> updates) {
        // Use parallel streams for concurrent updates
        updates.entrySet().parallelStream().forEach(entry -> {
            cache.put(entry.getKey(), entry.getValue());
        });
    }

    // Atomic increment operation
    public int atomicIncrement(String counterKey) {
        return Integer.parseInt(cache.compute(counterKey, (key, value) -> {
            int currentValue = value != null ? Integer.parseInt(value) : 0;
            return String.valueOf(currentValue + 1);
        }));
    }

    public static void main(String[] args) throws InterruptedException {
        ThreadSafeCacheExample example = new ThreadSafeCacheExample();

        // Run stress test
        example.stressTest(10, 1000);

        // Test atomic operations
        for (int i = 0; i < 100; i++) {
            int value = example.atomicIncrement("counter");
            System.out.println("Counter value: " + value);
        }
    }
}
`;

export const ADVANCED_CACHE_TYPES_EXAMPLE = `import io.github.dhruv1110.jcachex.kotlin.*
import io.github.dhruv1110.jcachex.eviction.FrequencySketchType
import kotlin.time.Duration.Companion.minutes
import kotlin.time.Duration.Companion.hours
import kotlin.time.Duration.Companion.seconds
import kotlinx.coroutines.delay
import kotlinx.coroutines.runBlocking

data class User(
    val id: String,
    val name: String,
    val email: String,
    val preferences: Map<String, String> = emptyMap()
)

data class Product(
    val id: String,
    val name: String,
    val price: Double,
    val category: String
)

data class UserSession(
    val userId: String,
    val timestamp: Long,
    val metadata: Map<String, String> = emptyMap()
)

class AdvancedCacheTypesExample {

    fun demonstrateAll() {
        println("=== JCacheX Advanced Cache Types Demo ===")

        // Demonstrate specialized cache types
        demonstrateReadOptimizedCache()
        demonstrateWriteOptimizedCache()
        demonstrateMemoryOptimizedCache()
        demonstrateHighPerformanceCache()

        // Demonstrate frequency sketch options
        demonstrateFrequencySketchOptions()

        // Demonstrate custom configurations
        demonstrateCustomConfigurations()

        // Performance comparison
        performanceComparison()
    }

    private fun demonstrateReadOptimizedCache() {
        println("\n=== Read-Optimized Cache (ReadOnly) ===")

        // Best for read-heavy scenarios - expected ~11.5ns GET performance
        val productCache = createReadOnlyOptimizedCache<String, Product> {
            maxSize = 5000
            expireAfterWrite = 2.hours
            recordStats = true
        }

        // Populate with product data
        repeat(1000) { i ->
            productCache["product-\$i"] = Product(
                id = "product-\$i",
                name = "Product \$i",
                price = 10.0 + i,
                category = "Category \${i % 10}"
            )
        }

        // Measure read performance
        val startTime = System.nanoTime()
        repeat(10000) { i ->
            productCache["product-\${i % 1000}"]
        }
        val endTime = System.nanoTime()

        println("Read-optimized GET time: \${(endTime - startTime) / 10000}ns per operation")
        println("Expected: ~11.5ns (1.6x faster than Caffeine)")

        with(productCache.stats()) {
            println("Hit rate: \${(hitRate() * 100).toInt()}%")
            println("Cache size: \${productCache.size()}")
        }
    }

    private fun demonstrateWriteOptimizedCache() {
        println("\n=== Write-Optimized Cache ===")

        // Best for write-heavy scenarios - expected ~393.5ns PUT performance
        val sessionCache = createWriteHeavyOptimizedCache<String, UserSession> {
            maxSize = 10000
            expireAfterAccess = 30.minutes
            recordStats = true
        }

        // Measure write performance
        val startTime = System.nanoTime()
        repeat(10000) { i ->
            sessionCache["session-\$i"] = UserSession(
                userId = "user-\$i",
                timestamp = System.currentTimeMillis(),
                metadata = mapOf("ip" to "192.168.1.\$i", "browser" to "Chrome")
            )
        }
        val endTime = System.nanoTime()

        println("Write-optimized PUT time: \${(endTime - startTime) / 10000}ns per operation")
        println("Expected: ~393.5ns (WriteHeavy optimized)")
        println("Cache size: \${sessionCache.size()}")
    }

    private fun demonstrateMemoryOptimizedCache() {
        println("\n=== Memory-Optimized Cache (Allocation) ===")

        // Minimizes GC pressure - expected ~39.7ns GET, ~88.5ns PUT
        val configCache = createAllocationOptimizedCache<String, String> {
            maxSize = 100
            expireAfterWrite = 12.hours
            recordStats = true
        }

        // Test memory efficiency
        repeat(100) { i ->
            configCache["config-\$i"] = "value-\$i".repeat(10) // Larger values
        }

        println("Memory-optimized cache size: \${configCache.size()}")
        println("Expected: Minimal GC pressure, ~39.7ns GET, ~88.5ns PUT")

        with(configCache.stats()) {
            println("Average load time: \${averageLoadTime()}ms")
            println("Eviction count: \${evictionCount()}")
        }
    }

    private fun demonstrateHighPerformanceCache() {
        println("\n=== High-Performance Cache (JIT Optimized) ===")

        // Balanced performance - expected ~24.6ns GET, ~63.8ns PUT
        val userCache = createJITOptimizedCache<String, User> {
            maxSize = 1000
            expireAfterWrite = 1.hours
            recordStats = true
        }

        // Performance test
        repeat(1000) { i ->
            userCache["user-\$i"] = User(
                id = "user-\$i",
                name = "User \$i",
                email = "user\$i@example.com",
                preferences = mapOf("theme" to "dark", "lang" to "en")
            )
        }

        // Measure balanced performance
        val startTime = System.nanoTime()
        repeat(10000) { i ->
            userCache["user-\${i % 1000}"]
        }
        val endTime = System.nanoTime()

        println("JIT-optimized GET time: \${(endTime - startTime) / 10000}ns per operation")
        println("Expected: ~24.6ns (balanced performance)")

        with(userCache.stats()) {
            println("Hit rate: \${(hitRate() * 100).toInt()}%")
            println("Request count: \${requestCount()}")
        }
    }

    private fun demonstrateFrequencySketchOptions() {
        println("\n=== Frequency Sketch Options ===")

        // No frequency sketch - minimal overhead
        val noSketchCache = cache<String, String> {
            maxSize = 1000
            evictionStrategy = EvictionStrategy.ENHANCED_LRU
            frequencySketchType = FrequencySketchType.NONE
            recordStats = true
        }

        // Basic frequency sketch - balanced approach (default)
        val basicSketchCache = cache<String, String> {
            maxSize = 1000
            evictionStrategy = EvictionStrategy.ENHANCED_LRU
            frequencySketchType = FrequencySketchType.BASIC
            recordStats = true
        }

        // Optimized frequency sketch - maximum accuracy
        val optimizedSketchCache = cache<String, String> {
            maxSize = 1000
            evictionStrategy = EvictionStrategy.ENHANCED_LFU
            frequencySketchType = FrequencySketchType.OPTIMIZED
            recordStats = true
        }

        // Test different access patterns
        testAccessPattern(noSketchCache, "No Sketch")
        testAccessPattern(basicSketchCache, "Basic Sketch")
        testAccessPattern(optimizedSketchCache, "Optimized Sketch")
    }

    private fun testAccessPattern(cache: Cache<String, String>, description: String) {
        // Populate cache
        repeat(2000) { i ->
            cache["key-\$i"] = "value-\$i"
        }

        // Hot keys pattern (80-20 rule)
        repeat(1000) {
            repeat(10) { j ->
                cache["key-\${j % 100}"] // Access first 100 keys repeatedly
            }
        }

        // Cold keys pattern
        (100..1999).forEach { i ->
            cache["key-\$i"] // Access once
        }

        with(cache.stats()) {
            println("\$description - Hit rate: \${(hitRate() * 100).toInt()}%")
        }
    }

    private fun demonstrateCustomConfigurations() {
        println("\n=== Custom Cache Configurations ===")

        // Ultra-fast cache with locality optimization
        val localityCache = createCacheLocalityOptimizedCache<String, String> {
            maxSize = 1000
            expireAfterWrite = 30.minutes
            recordStats = true
        }

        // Hardware-optimized cache
        val hardwareCache = createHardwareOptimizedCache<String, String> {
            maxSize = 1000
            expireAfterWrite = 30.minutes
            recordStats = true
        }

        // Test locality optimization (expected ~9.7ns GET)
        repeat(1000) { i ->
            localityCache["key-\$i"] = "value-\$i"
        }

        val startTime = System.nanoTime()
        repeat(10000) { i ->
            localityCache["key-\${i % 1000}"]
        }
        val endTime = System.nanoTime()

        println("Locality-optimized GET time: \${(endTime - startTime) / 10000}ns per operation")
        println("Expected: ~9.7ns (1.9x faster than Caffeine)")

        // Show cache type identification
        println("\nCache type identification:")
        println("Locality cache type: \${localityCache.cacheType}")
        println("Hardware cache type: \${hardwareCache.cacheType}")
    }

    private fun performanceComparison() {
        println("\n=== Performance Comparison ===")

        // Create different cache types for comparison
        val defaultCache = createDefaultCache<String, String> {
            maxSize = 1000
            recordStats = true
        }

        val jitCache = createJITOptimizedCache<String, String> {
            maxSize = 1000
            recordStats = true
        }

        val localityCache = createCacheLocalityOptimizedCache<String, String> {
            maxSize = 1000
            recordStats = true
        }

        val zeroCopyCache = createZeroCopyOptimizedCache<String, String> {
            maxSize = 1000
            recordStats = true
        }

        // Warm up caches
        repeat(1000) { i ->
            val key = "key-\$i"
            val value = "value-\$i"
            defaultCache[key] = value
            jitCache[key] = value
            localityCache[key] = value
            zeroCopyCache[key] = value
        }

        // Measure GET performance
        val iterations = 100000

        val defaultTime = measureTime {
            repeat(iterations) { i ->
                defaultCache["key-\${i % 1000}"]
            }
        }

        val jitTime = measureTime {
            repeat(iterations) { i ->
                jitCache["key-\${i % 1000}"]
            }
        }

        val localityTime = measureTime {
            repeat(iterations) { i ->
                localityCache["key-\${i % 1000}"]
            }
        }

        val zeroCopyTime = measureTime {
            repeat(iterations) { i ->
                zeroCopyCache["key-\${i % 1000}"]
            }
        }

        println("Performance Results (GET operations):")
        println("Default Cache: \${defaultTime / iterations}ns per operation")
        println("JIT Optimized: \${jitTime / iterations}ns per operation")
        println("Locality Optimized: \${localityTime / iterations}ns per operation")
        println("ZeroCopy Optimized: \${zeroCopyTime / iterations}ns per operation")

        println("\nExpected ranges:")
        println("Default: ~40.4ns")
        println("JIT: ~24.6ns")
        println("Locality: ~9.7ns")
        println("ZeroCopy: ~7.9ns (fastest)")
    }

    private fun measureTime(block: () -> Unit): Long {
        val startTime = System.nanoTime()
        block()
        return System.nanoTime() - startTime
    }
}

// Demonstration with coroutines
suspend fun demonstrateAsyncCaching() {
    println("\n=== Async Caching with Coroutines ===")

    val userCache = createJITOptimizedCache<String, User> {
        maxSize = 1000
        expireAfterWrite = 1.hours
        recordStats = true
    }

    // Simulate async data loading
    suspend fun loadUserFromDatabase(userId: String): User {
        delay(100) // Simulate database delay
        return User(
            id = userId,
            name = "User \$userId",
            email = "\$userId@example.com",
            preferences = mapOf("theme" to "dark", "notifications" to "enabled")
        )
    }

    // Async cache-aside pattern
    suspend fun getUser(userId: String): User? {
        return userCache[userId] ?: run {
            val user = loadUserFromDatabase(userId)
            userCache[userId] = user
            user
        }
    }

    // Test async operations
    val user = getUser("user123")
    println("Loaded user: \${user?.name}")

    // Second access should be from cache
    val cachedUser = getUser("user123")
    println("Cached user: \${cachedUser?.name}")

    with(userCache.stats()) {
        println("Hit rate: \${(hitRate() * 100).toInt()}%")
        println("Miss count: \${missCount()}")
    }
}

fun main() {
    val example = AdvancedCacheTypesExample()
    example.demonstrateAll()

    // Demonstrate async caching
    runBlocking {
        demonstrateAsyncCaching()
    }
}
`;

export const COROUTINES_EXAMPLE = `import io.github.dhruv1110.jcachex.kotlin.*
import kotlinx.coroutines.*
import kotlinx.coroutines.flow.*
import kotlin.time.Duration.Companion.minutes
import kotlin.time.Duration.Companion.seconds

class AsyncCacheService {

    private val cache = cache<String, String> {
        maxSize = 1000
        expireAfterWrite = 30.minutes
        recordStats = true
    }

    // Suspend function for async loading
    suspend fun getValueAsync(key: String): String {
        return cache[key] ?: loadValueAsync(key).also { value ->
            cache[key] = value
        }
    }

    // Parallel loading with coroutines
    suspend fun loadMultipleAsync(keys: List<String>): Map<String, String> {
        return coroutineScope {
            keys.map { key ->
                async { key to getValueAsync(key) }
            }.awaitAll().toMap()
        }
    }

    // Flow-based cache events
    fun cacheEvents(): Flow<CacheEvent> = flow {
        // Simulate cache events
        while (currentCoroutineContext().isActive) {
            delay(1000)
            emit(CacheEvent.HitRate(cache.stats().hitRate()))
        }
    }

    // Structured concurrency for cache operations
    suspend fun manageCacheLifecycle() = coroutineScope {
        // Launch cache warming
        val warmupJob = launch {
            warmCacheAsync()
        }

        // Launch cache cleanup
        val cleanupJob = launch {
            scheduleCleanup()
        }

        // Launch metrics collection
        val metricsJob = launch {
            collectMetrics()
        }

        // All jobs will be cancelled if parent scope is cancelled
        joinAll(warmupJob, cleanupJob, metricsJob)
    }

    // Cancellation-aware cache warming
    private suspend fun warmCacheAsync() {
        val keys = (1..1000).map { "key-\$it" }

        keys.chunked(100).forEach { chunk ->
            // Check for cancellation
            ensureActive()

            // Process chunk in parallel
            coroutineScope {
                chunk.map { key ->
                    async {
                        val value = "warm-\$key"
                        cache[key] = value
                    }
                }.awaitAll()
            }

            // Yield to other coroutines
            yield()
        }
    }

    // Periodic cache cleanup
    private suspend fun scheduleCleanup() {
        while (currentCoroutineContext().isActive) {
            delay(5.minutes)

            // Cleanup expired entries
            withContext(Dispatchers.Default) {
                cache.cleanUp()
            }
        }
    }

    // Metrics collection with Flow
    private suspend fun collectMetrics() {
        cacheEvents()
            .sample(30.seconds)
            .collect { event ->
                when (event) {
                    is CacheEvent.HitRate -> {
                        println("Cache hit rate: \${event.rate}")
                        if (event.rate < 0.7) {
                            println("WARNING: Low cache hit rate!")
                        }
                    }
                }
            }
    }

    // Timeout-aware cache operations
    suspend fun getWithTimeout(key: String, timeout: kotlin.time.Duration): String? {
        return try {
            withTimeout(timeout) {
                getValueAsync(key)
            }
        } catch (e: TimeoutCancellationException) {
            null
        }
    }

    // Channel-based cache updates
    suspend fun processUpdates(updates: ReceiveChannel<Pair<String, String>>) {
        for ((key, value) in updates) {
            cache[key] = value
            yield() // Cooperative cancellation
        }
    }

    private suspend fun loadValueAsync(key: String): String {
        // Simulate async loading
        delay(50)
        return "async-loaded-\$key"
    }
}

sealed class CacheEvent {
    data class HitRate(val rate: Double) : CacheEvent()
    data class SizeChange(val size: Long) : CacheEvent()
}
`;

export const EXTENSIONS_EXAMPLE = `import io.github.dhruv1110.jcachex.kotlin.*
import kotlin.time.Duration.Companion.minutes
import kotlin.time.Duration.Companion.hours
import kotlinx.coroutines.delay

data class User(
    val id: String,
    val name: String,
    val email: String,
    val preferences: Map<String, String> = emptyMap()
)

class UserCacheService {

    // Modern DSL-style cache configuration with convenience methods
    private val userCache = createReadHeavyCache<String, User> {
        name("users")
        maximumSize(1000L)
        expireAfterWrite(java.time.Duration.ofHours(2))
        expireAfterAccess(java.time.Duration.ofMinutes(30))
        recordStats(true)
    }

    // Alternative: Use specialized cache types for specific workloads
    private val readHeavyCache = createReadHeavyCache<String, User> {
        name("read-heavy-users")
        maximumSize(5000L)
        expireAfterWrite(java.time.Duration.ofHours(4))
        recordStats(true)
    }

    private val writeHeavyCache = createWriteHeavyCache<String, UserSession> {
        name("write-heavy-sessions")
        maximumSize(10000L)
        expireAfterAccess(java.time.Duration.ofMinutes(30))
        recordStats(true)
    }

    private val performanceCache = createHighPerformanceCache<String, User> {
        name("high-performance-users")
        maximumSize(1000L)
        expireAfterWrite(java.time.Duration.ofHours(1))
        recordStats(true)
    }

    // Operator overloading for intuitive access
    suspend fun getUser(userId: String): User? {
        return userCache[userId] ?: loadUserFromDatabase(userId)?.also { user ->
            userCache[userId] = user
        }
    }

    // Extension functions for common operations
    suspend fun cacheUser(user: User) {
        userCache[user.id] = user
    }

    fun removeUser(userId: String) {
        userCache -= userId  // Operator overloading for removal
    }

    // Batch operations with extension functions
    suspend fun cacheUsers(users: List<User>) {
        users.forEach { user ->
            userCache[user.id] = user
        }
    }

    // Cache warming with extension functions
    suspend fun warmCache() {
        val popularUsers = loadPopularUsers()
        popularUsers.forEach { user ->
            userCache[user.id] = user
        }
    }

    // Statistics with extension properties
    fun getCacheStats(): String {
        return buildString {
            with(userCache.stats()) {
                append("Hit Rate: \${(hitRate() * 100).toInt()}%\n")
                append("Size: \${userCache.size()}\n")
                append("Evictions: \${evictionCount()}\n")
                append("Avg Load Time: \${averageLoadTime()}ms")
            }
        }
    }

    // Type-safe cache operations
    inline fun <reified T> getCacheValue(key: String): T? {
        return userCache[key] as? T
    }

    // Extension function for conditional caching
    suspend fun cacheIfValid(user: User): Boolean {
        return if (user.email.isNotBlank()) {
            userCache[user.id] = user
            true
        } else {
            false
        }
    }

    private suspend fun loadUserFromDatabase(userId: String): User? {
        // Simulate database access
        delay(50)
        return User(
            id = userId,
            name = "User \$userId",
            email = "user\$userId@example.com",
            preferences = mapOf("theme" to "dark", "language" to "en")
        )
    }

    private suspend fun loadPopularUsers(): List<User> {
        // Simulate loading popular users
        delay(100)
        return (1..10).map { id ->
            User(
                id = "popular-\$id",
                name = "Popular User \$id",
                email = "popular\$id@example.com"
            )
        }
    }
}
`;

export const COMPUTATION_SERVICE_EXAMPLE = `import io.github.dhruv1110.jcachex.spring.annotation.JCacheXCacheable;
import org.springframework.stereotype.Service;
import org.springframework.scheduling.annotation.Async;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.TimeUnit;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

@Service
public class ComputationService {

    @JCacheXCacheable(cacheName = "fibonacciResults", key = "#n", expireAfterWrite = 60, expireAfterWriteUnit = TimeUnit.MINUTES, maximumSize = 1000)
    public BigInteger fibonacci(int n) {
        if (n <= 1) {
            return BigInteger.valueOf(n);
        }

        BigInteger prev = BigInteger.ZERO;
        BigInteger curr = BigInteger.ONE;

        for (int i = 2; i <= n; i++) {
            BigInteger next = prev.add(curr);
            prev = curr;
            curr = next;
        }

        return curr;
    }

    @JCacheXCacheable(cacheName = "primeFactors", key = "#number", expireAfterWrite = 30, expireAfterWriteUnit = TimeUnit.MINUTES)
    public List<Long> getPrimeFactors(long number) {
        List<Long> factors = new ArrayList<>();

        for (long i = 2; i * i <= number; i++) {
            while (number % i == 0) {
                factors.add(i);
                number /= i;
            }
        }

        if (number > 1) {
            factors.add(number);
        }

        return factors;
    }

    @JCacheXCacheable(cacheName = "reportData", key = "#startDate + '-' + #endDate + '-' + #reportType", expireAfterWrite = 2, expireAfterWriteUnit = TimeUnit.HOURS)
    public ReportData generateReport(LocalDate startDate, LocalDate endDate, String reportType) {
        // Simulate heavy report generation
        return switch (reportType) {
            case "SALES" -> generateSalesReport(startDate, endDate);
            case "ANALYTICS" -> generateAnalyticsReport(startDate, endDate);
            case "PERFORMANCE" -> generatePerformanceReport(startDate, endDate);
            default -> throw new IllegalArgumentException("Unknown report type: " + reportType);
        };
    }

    @Async
    @JCacheXCacheable(cacheName = "asyncComputations", key = "#taskId", expireAfterWrite = 45, expireAfterWriteUnit = TimeUnit.MINUTES)
    public CompletableFuture<ComputationResult> performAsyncComputation(String taskId, ComputationParameters params) {
        return CompletableFuture.supplyAsync(() -> {
            try {
                // Simulate heavy computation
                Thread.sleep(5000);

                double result = switch (params.getType()) {
                    case "MONTE_CARLO" -> performMonteCarloSimulation(params);
                    case "MATRIX_OPERATIONS" -> performMatrixOperations(params);
                    case "DATA_ANALYSIS" -> performDataAnalysis(params);
                    default -> 0.0;
                };

                return new ComputationResult(taskId, result, LocalDateTime.now());

            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                throw new RuntimeException("Computation interrupted", e);
            }
        });
    }

    @JCacheXCacheable(cacheName = "machineLearningPredictions", key = "#modelId + '-' + #inputData.hashCode()", expireAfterWrite = 15, expireAfterWriteUnit = TimeUnit.MINUTES)
    public PredictionResult predict(String modelId, InputData inputData) {
        // Simulate ML model prediction
        try {
            Thread.sleep(2000); // Simulate model inference time

            double prediction = performPrediction(modelId, inputData);
            double confidence = calculateConfidence(prediction, inputData);

            return new PredictionResult(
                    modelId,
                    prediction,
                    confidence,
                    LocalDateTime.now());

        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            throw new RuntimeException("Prediction interrupted", e);
        }
    }

    private ReportData generateSalesReport(LocalDate startDate, LocalDate endDate) {
        // Simulate heavy sales report generation
        try {
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            throw new RuntimeException(e);
        }

        return new ReportData(
                "SALES",
                Map.of(
                        "totalSales", BigDecimal.valueOf(1000000),
                        "totalOrders", BigDecimal.valueOf(5000),
                        "averageOrderValue", BigDecimal.valueOf(200)),
                startDate,
                endDate);
    }

    private ReportData generateAnalyticsReport(LocalDate startDate, LocalDate endDate) {
        // Simulate heavy analytics report generation
        try {
            Thread.sleep(4000);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            throw new RuntimeException(e);
        }

        return new ReportData(
                "ANALYTICS",
                Map.of(
                        "pageViews", BigDecimal.valueOf(500000),
                        "uniqueVisitors", BigDecimal.valueOf(25000),
                        "bounceRate", BigDecimal.valueOf(0.35)),
                startDate,
                endDate);
    }

    private ReportData generatePerformanceReport(LocalDate startDate, LocalDate endDate) {
        // Simulate heavy performance report generation
        try {
            Thread.sleep(2500);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            throw new RuntimeException(e);
        }

        return new ReportData(
                "PERFORMANCE",
                Map.of(
                        "averageResponseTime", BigDecimal.valueOf(150),
                        "errorRate", BigDecimal.valueOf(0.02),
                        "throughput", BigDecimal.valueOf(1000)),
                startDate,
                endDate);
    }

    private double performMonteCarloSimulation(ComputationParameters params) {
        // Simulate Monte Carlo simulation
        Random random = new Random();
        int iterations = params.getIterations();
        int insideCircle = 0;

        for (int i = 0; i < iterations; i++) {
            double x = random.nextDouble();
            double y = random.nextDouble();

            if (x * x + y * y <= 1) {
                insideCircle++;
            }
        }

        return 4.0 * insideCircle / iterations; // Approximation of π
    }

    private double performMatrixOperations(ComputationParameters params) {
        // Simulate matrix operations
        int size = params.getMatrixSize();
        double[][] matrix = new double[size][size];

        // Initialize matrix with random values
        Random random = new Random();
        for (int i = 0; i < size; i++) {
            for (int j = 0; j < size; j++) {
                matrix[i][j] = random.nextDouble();
            }
        }

        // Perform matrix operations (determinant calculation)
        return calculateDeterminant(matrix);
    }

    private double performDataAnalysis(ComputationParameters params) {
        // Simulate data analysis
        List<Double> data = generateRandomData(params.getDataSize());

        // Calculate statistics
        double mean = data.stream().mapToDouble(Double::doubleValue).average().orElse(0.0);
        double variance = data.stream()
                .mapToDouble(x -> Math.pow(x - mean, 2))
                .average()
                .orElse(0.0);

        return Math.sqrt(variance); // Standard deviation
    }

    private double performPrediction(String modelId, InputData inputData) {
        // Simulate ML prediction
        return inputData.getFeatures().stream()
                .mapToDouble(Double::doubleValue)
                .average()
                .orElse(0.0) * 1.5; // Simple prediction logic
    }

    private double calculateConfidence(double prediction, InputData inputData) {
        // Simulate confidence calculation
        return Math.min(0.95, 0.7 + Math.random() * 0.25);
    }

    private double calculateDeterminant(double[][] matrix) {
        // Simple determinant calculation for demonstration
        int n = matrix.length;
        if (n == 1)
            return matrix[0][0];
        if (n == 2)
            return matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0];

        double det = 0;
        for (int i = 0; i < n; i++) {
            det += Math.pow(-1, i) * matrix[0][i] * calculateDeterminant(getSubMatrix(matrix, 0, i));
        }
        return det;
    }

    private double[][] getSubMatrix(double[][] matrix, int excludeRow, int excludeCol) {
        int n = matrix.length;
        double[][] subMatrix = new double[n - 1][n - 1];
        int row = 0;

        for (int i = 0; i < n; i++) {
            if (i == excludeRow)
                continue;
            int col = 0;
            for (int j = 0; j < n; j++) {
                if (j == excludeCol)
                    continue;
                subMatrix[row][col] = matrix[i][j];
                col++;
            }
            row++;
        }
        return subMatrix;
    }

    private List<Double> generateRandomData(int size) {
        Random random = new Random();
        return IntStream.range(0, size)
                .mapToDouble(i -> random.nextGaussian())
                .boxed()
                .collect(Collectors.toList());
    }
}
`;

export const REST_API_EXAMPLE = `import io.github.dhruv1110.jcachex.spring.annotation.JCacheXCacheable;
import io.github.dhruv1110.jcachex.spring.annotation.JCacheXCacheEvict;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.client.RestTemplate;
import org.springframework.http.ResponseEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.CacheControl;
import org.springframework.stereotype.Service;
import java.util.concurrent.TimeUnit;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/api/v1")
public class UserController {

    private final UserService userService;
    private final ExternalApiService externalApiService;

    public UserController(UserService userService, ExternalApiService externalApiService) {
        this.userService = userService;
        this.externalApiService = externalApiService;
    }

    @GetMapping("/users/{id}")
    @JCacheXCacheable(cacheName = "userResponses", key = "#id", expireAfterWrite = 10, expireAfterWriteUnit = TimeUnit.MINUTES)
    public ResponseEntity<User> getUser(@PathVariable String id) {
        User user = userService.findById(id);

        return ResponseEntity.ok()
                .cacheControl(CacheControl.maxAge(10, TimeUnit.MINUTES))
                .body(user);
    }

    @GetMapping("/users")
    @JCacheXCacheable(cacheName = "userListResponses", key = "#page + '-' + #size + '-' + #sort", expireAfterWrite = 5, expireAfterWriteUnit = TimeUnit.MINUTES)
    public ResponseEntity<List<User>> getUsers(
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "10") int size,
            @RequestParam(defaultValue = "id") String sort) {

        List<User> users = userService.findUsers(page, size, sort);

        return ResponseEntity.ok()
                .cacheControl(CacheControl.maxAge(5, TimeUnit.MINUTES))
                .body(users);
    }

    @PostMapping("/users")
    @JCacheXCacheEvict(cacheName = "userListResponses")
    public ResponseEntity<User> createUser(@RequestBody User user) {
        User savedUser = userService.createUser(user);
        return ResponseEntity.ok(savedUser);
    }

    @PutMapping("/users/{id}")
    @JCacheXCacheEvict(cacheName = "userResponses", key = "#id")
    @JCacheXCacheEvict(cacheName = "userListResponses")
    public ResponseEntity<User> updateUser(@PathVariable String id, @RequestBody User user) {
        User updatedUser = userService.updateUser(id, user);
        return ResponseEntity.ok(updatedUser);
    }

    @DeleteMapping("/users/{id}")
    @JCacheXCacheEvict(cacheName = "userResponses", key = "#id")
    @JCacheXCacheEvict(cacheName = "userListResponses")
    public ResponseEntity<Void> deleteUser(@PathVariable String id) {
        userService.deleteUser(id);
        return ResponseEntity.noContent().build();
    }

    @GetMapping("/users/{id}/profile")
    @JCacheXCacheable(cacheName = "userProfiles", key = "#id + '-' + #includeDetails", expireAfterWrite = 30, expireAfterWriteUnit = TimeUnit.MINUTES)
    public ResponseEntity<UserProfile> getUserProfile(
            @PathVariable String id,
            @RequestParam(defaultValue = "false") boolean includeDetails) {

        UserProfile profile = userService.getUserProfile(id, includeDetails);

        return ResponseEntity.ok()
                .cacheControl(CacheControl.maxAge(30, TimeUnit.MINUTES))
                .body(profile);
    }
}

@Service
public class ExternalApiService {

    private final RestTemplate restTemplate;

    public ExternalApiService(RestTemplate restTemplate) {
        this.restTemplate = restTemplate;
    }

    @JCacheXCacheable(cacheName = "externalApiResponses", key = "#endpoint + '-' + #params.toString()", expireAfterWrite = 15, expireAfterWriteUnit = TimeUnit.MINUTES)
    public ApiResponse callExternalApi(String endpoint, Map<String, String> params) {
        String url = buildUrl(endpoint, params);

        try {
            return restTemplate.getForObject(url, ApiResponse.class);
        } catch (Exception e) {
            throw new ExternalApiException("Failed to call external API: " + endpoint, e);
        }
    }

    @JCacheXCacheable(cacheName = "weatherData", key = "#city + '-' + #country", expireAfterWrite = 30, expireAfterWriteUnit = TimeUnit.MINUTES)
    public WeatherData getWeatherData(String city, String country) {
        String endpoint = "https://api.weather.com/v1/current";
        Map<String, String> params = Map.of(
                "city", city,
                "country", country,
                "apikey", "your-api-key");

        ApiResponse response = callExternalApi(endpoint, params);
        return parseWeatherData(response);
    }

    private String buildUrl(String endpoint, Map<String, String> params) {
        StringBuilder url = new StringBuilder(endpoint);
        if (!params.isEmpty()) {
            url.append("?");
            url.append(params.entrySet().stream()
                    .map(entry -> entry.getKey() + "=" + entry.getValue())
                    .collect(Collectors.joining("&")));
        }
        return url.toString();
    }

    private WeatherData parseWeatherData(ApiResponse response) {
        // Parse weather data from API response
        return new WeatherData(
                response.getTemperature(),
                response.getHumidity(),
                response.getDescription());
    }
}
`;

export const SPRING_JPA_EXAMPLE = `import io.github.dhruv1110.jcachex.spring.annotation.JCacheXCacheable;
import io.github.dhruv1110.jcachex.spring.annotation.JCacheXCacheEvict;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.stereotype.Repository;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import javax.persistence.*;
import java.util.Optional;
import java.util.List;
import java.util.concurrent.TimeUnit;
import java.util.Map;

@Entity
@Table(name = "users")
public class User {
    @Id
    private String id;
    private String name;
    private String email;
    private boolean active;

    // Constructors, getters, setters
    public User() {
    }

    public User(String id, String name, String email, boolean active) {
        this.id = id;
        this.name = name;
        this.email = email;
        this.active = active;
    }

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    public boolean isActive() {
        return active;
    }

    public void setActive(boolean active) {
        this.active = active;
    }
}

@Repository
public interface UserRepository extends JpaRepository<User, String> {

    @JCacheXCacheable(cacheName = "usersByEmail", expireAfterWrite = 30, expireAfterWriteUnit = TimeUnit.MINUTES)
    Optional<User> findByEmail(String email);

    @JCacheXCacheable(cacheName = "activeUsers", expireAfterWrite = 15, expireAfterWriteUnit = TimeUnit.MINUTES)
    List<User> findByActiveTrue();

    @Query("SELECT u FROM User u WHERE u.name LIKE %:name%")
    @JCacheXCacheable(cacheName = "usersByName", key = "#name", expireAfterWrite = 20, expireAfterWriteUnit = TimeUnit.MINUTES)
    List<User> findByNameContaining(String name);
}

@Service
@Transactional
public class UserService {

    private final UserRepository userRepository;

    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    @JCacheXCacheable(cacheName = "users", expireAfterWrite = 60, expireAfterWriteUnit = TimeUnit.MINUTES, maximumSize = 10000)
    public User findById(String id) {
        return userRepository.findById(id)
                .orElseThrow(() -> new RuntimeException("User not found: " + id));
    }

    @JCacheXCacheable(cacheName = "userProfiles", key = "#userId", condition = "#includeDetails == true", expireAfterWrite = 45, expireAfterWriteUnit = TimeUnit.MINUTES)
    public UserProfile getUserProfile(String userId, boolean includeDetails) {
        User user = findById(userId);

        if (includeDetails) {
            return buildDetailedProfile(user);
        } else {
            return buildBasicProfile(user);
        }
    }

    @JCacheXCacheEvict(cacheName = "users")
    @JCacheXCacheEvict(cacheName = "usersByEmail", key = "#user.email")
    @JCacheXCacheEvict(cacheName = "activeUsers", condition = "#user.active")
    public User updateUser(User user) {
        return userRepository.save(user);
    }

    @JCacheXCacheEvict(cacheName = "users")
    @JCacheXCacheEvict(cacheName = "usersByEmail")
    @JCacheXCacheEvict(cacheName = "activeUsers")
    public void deleteUser(String userId) {
        userRepository.deleteById(userId);
    }

    // Bulk operations with cache management
    @JCacheXCacheEvict(cacheName = "activeUsers")
    public void activateUsers(List<String> userIds) {
        userIds.forEach(id -> {
            User user = findById(id);
            user.setActive(true);
            userRepository.save(user);
        });
    }

    private UserProfile buildDetailedProfile(User user) {
        return new UserProfile(
                user.getId(),
                user.getName(),
                user.getEmail(),
                user.isActive(),
                loadUserPermissions(user.getId()),
                loadUserPreferences(user.getId()));
    }

    private UserProfile buildBasicProfile(User user) {
        return new UserProfile(
                user.getId(),
                user.getName(),
                user.getEmail(),
                user.isActive(),
                null,
                null);
    }

    private List<String> loadUserPermissions(String userId) {
        // Load user permissions from database
        return List.of("READ", "WRITE");
    }

    private Map<String, String> loadUserPreferences(String userId) {
        // Load user preferences from database
        return Map.of("theme", "dark", "language", "en");
    }
}
`;

